// WASHPORTAL Worker (Full) — Portal + Admin endpoints
// Build: set via env.BUILD
export default {
  async fetch(req, env, ctx) {
    const origin = req.headers.get("Origin") || "*";

    const withCors = (res) => {
      const h = new Headers(res.headers);
      h.set("Access-Control-Allow-Origin", origin === "null" ? "*" : origin);
      h.set("Vary", "Origin");
      h.set("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
      h.set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-SA-Password");
      h.set("Access-Control-Max-Age", "86400");
      return new Response(res.body, { status: res.status, headers: h });
    };

    const j = (obj, status = 200) =>
      withCors(
        new Response(JSON.stringify(obj, null, 2), {
          status,
          headers: { "Content-Type": "application/json; charset=utf-8" },
        })
      );

    try {
      if (req.method === "OPTIONS") return withCors(new Response("", { status: 204 }));

      const url = new URL(req.url);
      const path = url.pathname;

      if (!env.DB) return j({ ok: false, error: "missing_db_binding", message: "DB binding fehlt (env.DB ist undefined)" }, 500);

      // health check that doesn't depend on any tables
      if (req.method === "GET" && path === "/api/_status") {
        return j({ ok: true, now: Date.now(), build: env.BUILD || "" });
      }

      await ensureSchema(env);

      // ----- helpers for auth -----
      const isSA = await isSuperAdmin(req, env);

// ---------- ADMIN CONFIG (SA only) ----------
if (req.method === "GET" && path === "/api/auth/admin/config/get") {
  if (!isSA) return j({ ok: false, error: "forbidden", message: "forbidden", build: env.BUILD || "" }, 403);
  const config = await getConfig(env);
  return j({ ok: true, build: env.BUILD || "", config });
}

if (req.method === "POST" && path === "/api/auth/admin/config/set") {
  if (!isSA) return j({ ok: false, error: "forbidden", message: "forbidden", build: env.BUILD || "" }, 403);
  const body = await readJson(req);
  const incoming = body?.config && typeof body.config === "object" ? body.config : (body || {});
  const allowed = [
    "daysPast","daysFuture","dryerMinutes","washerHours",
    "newsEnabled","newsText",
    "chatEnabled","whitecardEnabled","portalDebugEnabled",
    "washerPopup","dryerPopup"
  ];

  for (const k of allowed) {
    if (!(k in incoming)) continue;
    let v = incoming[k];

    if (k === "washerHours") {
      if (!Array.isArray(v)) continue;
      v = JSON.stringify(v.map(n => Number(n)).filter(n => Number.isFinite(n)));
    } else if (["daysPast","daysFuture","dryerMinutes"].includes(k)) {
      v = String(Number(v || 0));
    } else if (typeof v === "boolean") {
      v = v ? "true" : "false";
    } else {
      v = String(v ?? "");
    }

    await env.DB.prepare(
      `INSERT INTO wp_config(key,value) VALUES(?,?)
       ON CONFLICT(key) DO UPDATE SET value=excluded.value`
    ).bind(k, v).run();
  }

  const config = await getConfig(env);
  return j({ ok: true, build: env.BUILD || "", config });
}

if (req.method === "POST" && path === "/api/admin/set-station-pin") {
  if (!isSA) return j({ ok: false, error: "forbidden", message: "forbidden", build: env.BUILD || "" }, 403);
  const body = await readJson(req);
  const pin = String(body?.pin || body?.stationPin || "").trim();
  if (!pin) return j({ ok: false, error: "missing_pin", message: "missing_pin", build: env.BUILD || "" }, 400);

  const hash = await hashPbkdf2(pin);

  await env.DB.prepare(
    `INSERT INTO wp_config(key,value) VALUES('stationPinHash',?)
     ON CONFLICT(key) DO UPDATE SET value=excluded.value`
  ).bind(hash).run();

  return j({ ok: true, build: env.BUILD || "", stationPinHash: "set" });
}

      // ===== PORTAL =====
      if (req.method === "POST" && path === "/api/user/refresh") {
        const body = await readJson(req);
        const auth = await requirePortalAuth(env, body);

        const lock = await getRoomLock(env, auth.room);
        const config = await getConfig(env);
        const machines = await getMachines(env);
        const mstate = await getMachineStateMap(env);
        const machinesMerged = machines.map(m => ({
          ...m,
          adminLocked: !!mstate[`${m.kind}:${m.machineId}`]?.adminLocked,
          defect: !!mstate[`${m.kind}:${m.machineId}`]?.defect,
        }));

        const { bookings, myBookings } = await getBookings(env, {
          room: auth.room,
          pinHash: auth.pinHash,
          daysPast: config.daysPast,
          daysFuture: config.daysFuture,
        });

        return j({
          ok: true,
          build: env.BUILD || "",
          user: { id: auth.userId, email: "", firstName: "", lastName: "", role: "user", status: "active", room: auth.room },
          config,
          machines: machinesMerged,
          bookings,
          myBookings,
          room: auth.room,
          blocked: lock.blocked,
          message: lock.message || "",
          updatedAt: Date.now(),
        });
      }

      if (req.method === "POST" && path === "/api/room/control/check") {
        const body = await readJson(req);
        const room = String(body.room || "").trim();
        if (!room) throw httpErr(400, "missing_room");
        const lock = await getRoomLock(env, room);
        return j({ ok: true, build: env.BUILD || "", room, blocked: lock.blocked, message: lock.message || "", updatedAt: lock.updatedAt });
      }

      if (req.method === "POST" && path === "/api/washer/book") {
        const body = await readJson(req);
        const auth = await requirePortalAuth(env, body);

        const lock = await getRoomLock(env, auth.room);
        if (lock.blocked) throw httpErr(403, "room_locked");

        const machineId = String(body.machineId || "").trim();
        const minutes = toInt(body.minutes, 60);
        const startAt = toInt(body.startAt, 0);

        if (!machineId) throw httpErr(400, "missing_machineId");
        if (!startAt) throw httpErr(400, "missing_startAt");

        // Allow booking of running-but-free slots: only block if booking ended in past
        const endAt = startAt + minutes * 60_000;
        if (endAt < Date.now() - 60_000) throw httpErr(400, "slot_in_past");

        await assertMachineBookable(env, "washer", machineId);

        const id = crypto.randomUUID();
        await insertBooking(env, {
          id,
          type: "washer",
          machine: toInt(machineId, 0),
          start: startAt,
          end: endAt,
          room: auth.room,
          pinHash: auth.pinHash,
          status: "booked",
        });

        await logEvent(env, auth.userId, "booking.create", auth.room, { id, type: "washer", machineId, startAt, endAt });

        return j({ ok: true, id, type: "washer", machineId, startAt, endAt });
      }

      if (req.method === "POST" && path === "/api/dryer/book") {
        const body = await readJson(req);
        const auth = await requirePortalAuth(env, body);

        const lock = await getRoomLock(env, auth.room);
        if (lock.blocked) throw httpErr(403, "room_locked");

        const machineId = String(body.machineId || "").trim();
        if (!machineId) throw httpErr(400, "missing_machineId");

        await assertMachineBookable(env, "dryer", machineId);

        const config = await getConfig(env);
        const minutes = toInt(body.minutes, toInt(config.dryerMinutes, 150));

        const id = crypto.randomUUID();
        const startAt = Date.now();
        const endAt = startAt + minutes * 60_000;

        await insertBooking(env, {
          id,
          type: "dryer",
          machine: toInt(machineId, 0),
          start: startAt,
          end: endAt,
          room: auth.room,
          pinHash: auth.pinHash,
          status: "booked",
        });

        await logEvent(env, auth.userId, "booking.create", auth.room, { id, type: "dryer", machineId, startAt, endAt });

        return j({ ok: true, id, type: "dryer", machineId, startAt, endAt });
      }

      if (req.method === "POST" && path === "/api/booking/release") {
        const body = await readJson(req);
        const auth = await requirePortalAuth(env, body);

        const lock = await getRoomLock(env, auth.room);
        if (lock.blocked) throw httpErr(403, "room_locked");

        const bookingId = String(body.bookingId || body.id || "").trim();
        if (!bookingId) throw httpErr(400, "missing_bookingId");

        const row = await env.DB.prepare(`SELECT id, room, pinHash, status, start, end FROM bookings WHERE id=?`)
          .bind(bookingId).first();

        if (!row) throw httpErr(404, "not_found");
        if (String(row.room) !== String(auth.room)) throw httpErr(403, "forbidden_room");
        if (String(row.pinHash) !== String(auth.pinHash)) throw httpErr(403, "forbidden_pin");
        if (String(row.status) !== "booked" && String(row.status) !== "active") throw httpErr(400, "not_booked");

        // cannot cancel/release bookings fully in the past
        if (toInt(row.end, 0) < Date.now()) throw httpErr(400, "slot_in_past");

        await env.DB.prepare(`UPDATE bookings SET status='released', releasedAt=? WHERE id=?`)
          .bind(Date.now(), bookingId).run();

        await logEvent(env, auth.userId, "booking.release", auth.room, { id: bookingId });

        return j({ ok: true, id: bookingId, status: "released" });
      }

      // Defekt melden (optional text) + machine defect state set immediately; bookings remain
      if (req.method === "POST" && (path === "/api/defect/report" || path === "/api/machine/defect")) {
        const body = await readJson(req);
        const auth = await requirePortalAuth(env, body);

        const kind = String(body.kind || body.type || "").trim() || null;
        const machineId = String(body.machineId || "").trim();
        const text = String(body.text || body.message || "").trim(); // optional

        if (!machineId) throw httpErr(400, "missing_machineId");
        if (!kind) throw httpErr(400, "missing_kind");

        // if admin disabled user defect reports, block
        const cfg = await getConfig(env);
        if (!cfg.userDefectEnabled) throw httpErr(403, "defect_reporting_disabled");

        const id = crypto.randomUUID();
        await env.DB.prepare(`INSERT INTO defects(id,room,machineId,text,createdAt) VALUES(?,?,?,?,?)`)
          .bind(id, String(auth.room), `${kind}:${machineId}`, text, Date.now()).run();

        await upsertMachineState(env, kind, machineId, { defect: 1 });

        await logEvent(env, auth.userId, "defect.report", auth.room, { id, kind, machineId, text });

        return j({ ok: true, id });
      }

      // ===== ADMIN / AUTH =====
      if (req.method === "POST" && path === "/api/ps/login") {
        // lightweight: allow SA password login as PS session too
        const body = await readJson(req);
        if (isSA) return j({ ok: true, token: "sa", role: "sa", build: env.BUILD || "" });
        // optional: allow a fixed PS_PASSWORD
        const pw = String(body.password || "");
        const psPw = env.PS_PASSWORD || "";
        if (psPw && pw === psPw) return j({ ok: true, token: "ps", role: "ps", build: env.BUILD || "" });
        throw httpErr(403, "forbidden");
      }

if (req.method === "GET" && path === "/api/auth/me") {
  const ok = await isSuperAdmin(req, env);
  if (!ok) return j({ ok: false, error: "forbidden", message: "forbidden", build: env.BUILD || "" }, 403);

  // Admin-UI expects a flat "perms" list on the user object.
  const snap = await getRbacSnapshot(env);
  const perms = ["sa.all"];

  return j({
    ok: true,
    build: env.BUILD || "",
    user: { id: "sa", email: "", firstName: "", lastName: "", role: "sa", roleLabel: "SA", status: "active", perms },
    rbac: snap,
  });
}

      // config get/set (admin)
      if (path === "/api/auth/admin/config/get" && req.method === "GET") {
        if (!isSA) throw httpErr(403, "forbidden");
        const config = await getConfig(env);
        return j({ ok: true, build: env.BUILD || "", config });
      }

      if (path === "/api/auth/admin/config/set" && req.method === "POST") {
        if (!isSA) throw httpErr(403, "forbidden");
        const body = await readJson(req);
        const patch = body?.config || body || {};
        const cfg = await getConfig(env);
        const merged = { ...cfg, ...sanitizeConfigPatch(patch) };
        await setConfig(env, merged);
        await logEvent(env, "sa", "config.set", "", { keys: Object.keys(patch || {}) });
        return j({ ok: true, build: env.BUILD || "", config: merged });
      }

      // station pin set
      if (path === "/api/admin/set-station-pin" && req.method === "POST") {
        if (!isSA) throw httpErr(403, "forbidden");
        const body = await readJson(req);
        const pin = String(body.pin || body.stationPin || "").trim();
        if (!pin) throw httpErr(400, "missing_pin");
        const hash = await hashPbkdf2(pin);
        const cfg = await getConfig(env);
        cfg.stationPinHash = hash;
        await setConfig(env, cfg);
        await logEvent(env, "sa", "stationPin.set", "", {});
        return j({ ok: true, build: env.BUILD || "" });
      }

      // RBAC snapshot endpoints
      if (path === "/api/auth/admin/rbac/snapshot" && req.method === "GET") {
        if (!isSA) throw httpErr(403, "forbidden");
        const snap = await getRbacSnapshot(env);
        return j({ ok: true, build: env.BUILD || "", rbac: snap });
      }

      // Machines admin get/set state
      if (path === "/api/auth/admin/machines/get" && req.method === "GET") {
        if (!isSA) throw httpErr(403, "forbidden");
        const machines = await getMachines(env);
        const mstate = await getMachineStateMap(env);
        const merged = machines.map(m => ({
          ...m,
          adminLocked: !!mstate[`${m.kind}:${m.machineId}`]?.adminLocked,
          defect: !!mstate[`${m.kind}:${m.machineId}`]?.defect,
        }));
        return j({ ok: true, build: env.BUILD || "", machines: merged });
      }

      if (path === "/api/auth/admin/machines/set" && req.method === "POST") {
        if (!isSA) throw httpErr(403, "forbidden");
        const body = await readJson(req);
        const kind = String(body.kind || "").trim();
        const machineId = String(body.machineId || "").trim();
        if (!kind || !machineId) throw httpErr(400, "missing_machine");
        const patch = {
          adminLocked: body.adminLocked ? 1 : 0,
          defect: body.defect ? 1 : 0,
        };
        await upsertMachineState(env, kind, machineId, patch);
        await logEvent(env, "sa", "machine.set", "", { kind, machineId, ...patch });
        return j({ ok: true, build: env.BUILD || "" });
      }

      // Room lock set
      if (path === "/api/auth/admin/room/lock" && req.method === "POST") {
        if (!isSA) throw httpErr(403, "forbidden");
        const body = await readJson(req);
        const room = String(body.room || "").trim();
        const blocked = body.blocked ? 1 : 0;
        const message = String(body.message || "").trim();
        if (!room) throw httpErr(400, "missing_room");
        await env.DB.prepare(`INSERT INTO room_locks(room,blocked,message,updatedAt) VALUES(?,?,?,?)
          ON CONFLICT(room) DO UPDATE SET blocked=excluded.blocked, message=excluded.message, updatedAt=excluded.updatedAt`)
          .bind(room, blocked, message, Date.now()).run();
        await logEvent(env, "sa", "room.lock", room, { blocked: !!blocked, message });
        return j({ ok: true, build: env.BUILD || "" });
      }

      // Logs (simple)
      if (path === "/api/auth/admin/logs" && req.method === "GET") {
        if (!isSA) throw httpErr(403, "forbidden");
        const rows = await env.DB.prepare(`SELECT id,ts,actor,action,room,meta FROM logs ORDER BY ts DESC LIMIT 500`).all();
        return j({ ok: true, build: env.BUILD || "", logs: rows.results || [] });
      }

      // Bookings list (simple)
      if (path === "/api/auth/admin/bookings" && req.method === "GET") {
        if (!isSA) throw httpErr(403, "forbidden");
        const rows = await env.DB.prepare(`SELECT id,type,machine,start,end,room,status,createdAt,cancelledAt,releasedAt FROM bookings ORDER BY start DESC LIMIT 500`).all();
        return j({ ok: true, build: env.BUILD || "", bookings: (rows.results || []).map(mapBookingRow) });
      }

      // fallback
      return j({ ok: false, error: "not_found", message: "not_found", path }, 404);

    } catch (e) {
      const status = e?.status || 500;
      return j({
        ok: false,
        error: status === 500 ? "internal_error" : "error",
        message: e?.message || "internal_error",
        stack: String(e?.stack || ""),
        build: env.BUILD || ""
      }, status);
    }
  }
};

/* ================= helpers ================= */

async function readJson(req) {
  const ct = req.headers.get("content-type") || "";
  if (!ct.includes("application/json")) return {};
  return await req.json();
}
function httpErr(status, message) { const e = new Error(message); e.status = status; return e; }
function toInt(v, d=0) { const n = Number(v); return Number.isFinite(n) ? Math.trunc(n) : d; }

async function isSuperAdmin(req, env) {
  const pass = req.headers.get("X-SA-Password") || req.headers.get("x-sa-password") || "";
  const envPass = env.SA_PASSWORD || env.SA_PASS || "";
  return !!envPass && pass && pass === envPass;
}

/* ================= schema ================= */

async function ensureSchema(env) {
  // NOTE: D1 sometimes errors with internal meta aggregation. Avoid DB.exec; run statements separately.
  const stmts = [
    `CREATE TABLE IF NOT EXISTS wp_config ( key TEXT PRIMARY KEY, value TEXT NOT NULL )`,
    `CREATE TABLE IF NOT EXISTS room_auth ( room TEXT PRIMARY KEY, pinHash TEXT NOT NULL, pinId TEXT NOT NULL, updatedAt INTEGER NOT NULL )`,
    `CREATE TABLE IF NOT EXISTS room_locks ( room TEXT PRIMARY KEY, blocked INTEGER NOT NULL DEFAULT 0, message TEXT NOT NULL DEFAULT '', updatedAt INTEGER NOT NULL DEFAULT 0 )`,
    // machines: legacy-safe (we will ALTER to add missing columns below)
    `CREATE TABLE IF NOT EXISTS machines ( machineId TEXT )`,
    `CREATE TABLE IF NOT EXISTS machine_state ( kind TEXT NOT NULL, machineId TEXT NOT NULL, adminLocked INTEGER NOT NULL DEFAULT 0, defect INTEGER NOT NULL DEFAULT 0, updatedAt INTEGER NOT NULL DEFAULT 0, PRIMARY KEY(kind, machineId) )`,
    `CREATE TABLE IF NOT EXISTS defects ( id TEXT PRIMARY KEY, room TEXT NOT NULL, machineId TEXT NOT NULL DEFAULT '', text TEXT NOT NULL DEFAULT '', createdAt INTEGER NOT NULL )`,
    `CREATE TABLE IF NOT EXISTS logs ( id TEXT PRIMARY KEY, ts INTEGER NOT NULL, actor TEXT NOT NULL, action TEXT NOT NULL, room TEXT NOT NULL, meta TEXT NOT NULL )`,
  ];
  for (const s of stmts) await env.DB.prepare(s).run();

  await ensureMachinesColumns(env);

  // seed machines if empty (after columns ensured)
  const c = await env.DB.prepare(`SELECT COUNT(*) as c FROM machines`).first();
  if (toInt(c?.c, 0) === 0) {
    const stmt = env.DB.prepare(`INSERT INTO machines(kind,machineId,label,enabled,minutes) VALUES(?,?,?,?,?)`);
    for (let i = 1; i <= 4; i++) await stmt.bind("washer", String(i), String(i), 1, 0).run();
    for (let i = 1; i <= 4; i++) await stmt.bind("dryer", String(i), String(i), 1, 0).run();
  }

  // bookings table (your live schema) — create if missing
  await env.DB.prepare(`
    CREATE TABLE IF NOT EXISTS bookings (
      id TEXT PRIMARY KEY,
      type TEXT NOT NULL,
      machine INTEGER NOT NULL,
      start INTEGER NOT NULL,
      end INTEGER NOT NULL,
      room TEXT NOT NULL,
      pinHash TEXT NOT NULL,
      status TEXT NOT NULL,
      createdAt INTEGER NOT NULL,
      cancelledAt INTEGER NOT NULL DEFAULT 0,
      releasedAt INTEGER NOT NULL DEFAULT 0
    )
  `).run();
}

/* ================= config ================= */

function defaultConfig() {
  return {
    daysPast: 7,
    daysFuture: 6,
    dryerMinutes: 150,
    washerHours: [6, 8, 10, 12, 14, 16, 18, 20],
    newsEnabled: false,
    newsText: "",
    chatEnabled: false,
    whitecardEnabled: false,
    portalDebugEnabled: false,
    washerPopup: false,
    dryerPopup: false,
    stationPinHash: "",
    userDefectEnabled: true,
  };
}
function sanitizeConfigPatch(patch) {
  const out = {};
  for (const [k, v] of Object.entries(patch || {})) {
    if (k === "washerHours") {
      if (Array.isArray(v)) out.washerHours = v.map(x => toInt(x, 0)).filter(x => x >= 0 && x <= 23);
    } else if (["daysPast","daysFuture","dryerMinutes"].includes(k)) {
      out[k] = toInt(v, defaultConfig()[k]);
    } else if (typeof defaultConfig()[k] === "boolean") {
      out[k] = !!v;
    } else if (typeof defaultConfig()[k] === "string") {
      out[k] = String(v ?? "");
    }
  }
  return out;
}

async function getConfig(env) {
  const defaults = defaultConfig();
  // prefer wp_config
  try {
    const rows = await env.DB.prepare(`SELECT key,value FROM wp_config`).all();
    const cfg = { ...defaults };
    for (const r of (rows.results || [])) applyKV(cfg, String(r.key), r.value);
    return cfg;
  } catch {
    return { ...defaults };
  }
}
function applyKV(cfg, k, raw) {
  if (!(k in cfg)) return;
  if (k === "washerHours") {
    try { cfg[k] = JSON.parse(String(raw)); } catch { cfg[k] = defaultConfig().washerHours; }
    return;
  }
  if (typeof cfg[k] === "number") cfg[k] = toInt(raw, cfg[k]);
  else if (typeof cfg[k] === "boolean") cfg[k] = String(raw) === "true";
  else cfg[k] = String(raw ?? "");
}
async function setConfig(env, cfg) {
  const stmt = env.DB.prepare(`INSERT INTO wp_config(key,value) VALUES(?,?)
    ON CONFLICT(key) DO UPDATE SET value=excluded.value`);
  for (const [k, v] of Object.entries(cfg || {})) {
    const val = k === "washerHours" ? JSON.stringify(v || []) : String(v);
    await stmt.bind(k, val).run();
  }
}

async function tableInfo(env, table) {
  try {
    const res = await env.DB.prepare(`PRAGMA table_info(${table})`).all();
    return (res.results || []).map(r => ({ name: String(r.name), type: String(r.type || ""), notnull: toInt(r.notnull, 0) }));
  } catch {
    return [];
  }
}
function hasCol(cols, name) { return cols.some(c => c.name === name); }

async function ensureMachinesColumns(env) {
  const cols = await tableInfo(env, "machines");
  // desired columns
  const desired = [
    ["kind", "TEXT"],
    ["machineId", "TEXT"],
    ["label", "TEXT"],
    ["enabled", "INTEGER"],
    ["minutes", "INTEGER"],
  ];
  for (const [c, t] of desired) {
    if (!hasCol(cols, c)) {
      try { await env.DB.prepare(`ALTER TABLE machines ADD COLUMN ${c} ${t}`).run(); } catch {}
    }
  }

  // If we only had legacy columns, attempt to backfill
  const cols2 = await tableInfo(env, "machines");

  // If machineId is NULL but there is a legacy integer column 'machine', copy it
  if (hasCol(cols2, "machine") && hasCol(cols2, "machineId")) {
    try { await env.DB.prepare(`UPDATE machines SET machineId=CAST(machine AS TEXT) WHERE (machineId IS NULL OR machineId='')`).run(); } catch {}
  }
  // If kind is NULL but there is a legacy column 'type'
  if (hasCol(cols2, "type") && hasCol(cols2, "kind")) {
    try { await env.DB.prepare(`UPDATE machines SET kind=type WHERE (kind IS NULL OR kind='')`).run(); } catch {}
  }
  // If label missing, default to machineId
  if (hasCol(cols2, "label") && hasCol(cols2, "machineId")) {
    try { await env.DB.prepare(`UPDATE machines SET label=machineId WHERE (label IS NULL OR label='')`).run(); } catch {}
  }
  // If enabled missing values, default 1
  if (hasCol(cols2, "enabled")) {
    try { await env.DB.prepare(`UPDATE machines SET enabled=1 WHERE enabled IS NULL`).run(); } catch {}
  }
  // If minutes missing values, default 0
  if (hasCol(cols2, "minutes")) {
    try { await env.DB.prepare(`UPDATE machines SET minutes=0 WHERE minutes IS NULL`).run(); } catch {}
  }

  // If kind is still empty for all rows but we have exactly 8 rows and no kind, assume first half washers and second half dryers (best-effort)
  try {
    const k = await env.DB.prepare(`SELECT COUNT(*) as c FROM machines WHERE kind IS NOT NULL AND kind!=''`).first();
    if (toInt(k?.c,0) === 0) {
      // no data or unknown -> leave; seeding handles empty case
    }
  } catch {}
}


/* ================= machines ================= */

async function getMachines(env) {
  const cols = await tableInfo(env, "machines");
  // pick columns with fallbacks
  const kindCol = hasCol(cols, "kind") ? "kind" : (hasCol(cols, "type") ? "type" : "''");
  const idCol = hasCol(cols, "machineId") ? "machineId" : (hasCol(cols, "machine") ? "CAST(machine AS TEXT)" : "''");
  const labelCol = hasCol(cols, "label") ? "label" : idCol;
  const enabledCol = hasCol(cols, "enabled") ? "enabled" : "1";
  const minutesCol = hasCol(cols, "minutes") ? "minutes" : "0";

  const sql = `SELECT ${kindCol} as kind, ${idCol} as machineId, ${labelCol} as label, ${enabledCol} as enabled, ${minutesCol} as minutes
               FROM machines
               ORDER BY CASE WHEN kind='washer' THEN 0 ELSE 1 END, CAST(machineId as INTEGER)`;
  const rows = await env.DB.prepare(sql).all();
  return (rows.results || []).map(r => ({
    machineId: String(r.machineId),
    kind: String(r.kind),
    label: String(r.label ?? r.machineId),
    enabled: !!toInt(r.enabled, 0),
    minutes: toInt(r.minutes, 0),
  }));
}
async function getMachineStateMap(env) {
  const rows = await env.DB.prepare(`SELECT kind,machineId,adminLocked,defect,updatedAt FROM machine_state`).all();
  const m = {};
  for (const r of (rows.results || [])) {
    m[`${r.kind}:${r.machineId}`] = {
      adminLocked: !!toInt(r.adminLocked, 0),
      defect: !!toInt(r.defect, 0),
      updatedAt: toInt(r.updatedAt, 0),
    };
  }
  return m;
}
async function upsertMachineState(env, kind, machineId, patch) {
  const cur = await env.DB.prepare(`SELECT adminLocked,defect FROM machine_state WHERE kind=? AND machineId=?`)
    .bind(kind, machineId).first();
  const adminLocked = patch.adminLocked !== undefined ? toInt(patch.adminLocked, 0) : toInt(cur?.adminLocked, 0);
  const defect = patch.defect !== undefined ? toInt(patch.defect, 0) : toInt(cur?.defect, 0);

  await env.DB.prepare(
    `INSERT INTO machine_state(kind,machineId,adminLocked,defect,updatedAt) VALUES(?,?,?,?,?)
     ON CONFLICT(kind,machineId) DO UPDATE SET adminLocked=excluded.adminLocked, defect=excluded.defect, updatedAt=excluded.updatedAt`
  ).bind(kind, machineId, adminLocked, defect, Date.now()).run();
}
async function assertMachineBookable(env, kind, machineId) {
  const m = await env.DB.prepare(`SELECT enabled FROM machines WHERE kind=? AND machineId=?`).bind(kind, machineId).first();
  if (m && !toInt(m.enabled, 1)) throw httpErr(403, "machine_disabled");
  const st = await env.DB.prepare(`SELECT adminLocked,defect FROM machine_state WHERE kind=? AND machineId=?`).bind(kind, machineId).first();
  if (st && toInt(st.adminLocked, 0)) throw httpErr(403, "machine_locked");
  if (st && toInt(st.defect, 0)) throw httpErr(403, "machine_defect");
}

/* ================= room lock ================= */

async function getRoomLock(env, room) {
  const row = await env.DB.prepare(`SELECT blocked,message,updatedAt FROM room_locks WHERE room=?`)
    .bind(String(room)).first();
  if (!row) return { blocked: false, message: "", updatedAt: 0 };
  return { blocked: !!toInt(row.blocked, 0), message: String(row.message || ""), updatedAt: toInt(row.updatedAt, 0) };
}

/* ================= auth (portal) ================= */

async function requirePortalAuth(env, body) {
  const room = String(body.room || "").trim();
  const pin = String(body.pin || "").trim();
  const stationPin = String(body.stationPin || "").trim();
  if (!room || !pin || !stationPin) throw httpErr(403, "forbidden");

  const cfg = await getConfig(env);
  if (!cfg.stationPinHash) throw httpErr(403, "station_pin_not_set");

  const stationOk = await verifyPbkdf2(stationPin, cfg.stationPinHash);
  if (!stationOk) throw httpErr(403, "forbidden");

  const ra = await env.DB.prepare(`SELECT room,pinHash,pinId FROM room_auth WHERE room=?`).bind(room).first();

  if (!ra) {
    const pinHash = await hashPbkdf2(pin);
    const pinId = crypto.randomUUID();
    await env.DB.prepare(`INSERT INTO room_auth(room,pinHash,pinId,updatedAt) VALUES(?,?,?,?)`)
      .bind(room, pinHash, pinId, Date.now()).run();
    return { room, pinHash, userId: `room:${room}:${pinId}` };
  }

  const ok = await verifyPbkdf2(pin, String(ra.pinHash));
  if (ok) return { room, pinHash: String(ra.pinHash), userId: `room:${room}:${String(ra.pinId)}` };

  // mismatch -> new resident; rotate pin (new resident must not see old bookings => new pinHash)
  const pinHash = await hashPbkdf2(pin);
  const pinId = crypto.randomUUID();
  await env.DB.prepare(`UPDATE room_auth SET pinHash=?, pinId=?, updatedAt=? WHERE room=?`)
    .bind(pinHash, pinId, Date.now(), room).run();
  await logEvent(env, `room:${room}:${String(ra.pinId)}`, "room.pin.rotate", room, { reason: "pin_mismatch" });
  return { room, pinHash, userId: `room:${room}:${pinId}` };
}

/* ================= bookings ================= */

function mapBookingRow(r) {
  const startAt = toInt(r.start, 0);
  const endAt = toInt(r.end, 0);
  const durationMinutes = Math.max(0, Math.round((endAt - startAt) / 60000));
  let status = String(r.status || "");
  // optional: derive active if within window and still booked
  if (status === "booked" && startAt <= Date.now() && endAt > Date.now()) status = "active";
  return {
    id: String(r.id),
    room: String(r.room),
    machineId: String(r.machine),
    kind: String(r.type),
    status,
    startAt,
    endAt,
    durationMinutes,
    duration: durationMinutes,
    userId: "",
  };
}

async function insertBooking(env, b) {
  await env.DB.prepare(
    `INSERT INTO bookings(id,type,machine,start,end,room,pinHash,status,createdAt,cancelledAt,releasedAt)
     VALUES(?,?,?,?,?,?,?,?,?,?,?)`
  ).bind(
    String(b.id),
    String(b.type),
    toInt(b.machine, 0),
    toInt(b.start, 0),
    toInt(b.end, 0),
    String(b.room),
    String(b.pinHash),
    String(b.status),
    Date.now(),
    0,
    0
  ).run();
}

async function getBookings(env, { room, pinHash, daysPast, daysFuture }) {
  const t0 = Date.now() - toInt(daysPast, 7) * 86400000;
  const t1 = Date.now() + toInt(daysFuture, 6) * 86400000;

  const rows = await env.DB.prepare(
    `SELECT id,type,machine,start,end,room,status,createdAt,cancelledAt,releasedAt
     FROM bookings
     WHERE start BETWEEN ? AND ?
     ORDER BY start ASC`
  ).bind(t0, t1).all();

  const bookings = (rows.results || []).map(mapBookingRow);

  // myBookings MUST be pinHash-filtered => new resident sees nothing old
  const mineRows = await env.DB.prepare(
    `SELECT id,type,machine,start,end,room,status,createdAt,cancelledAt,releasedAt
     FROM bookings
     WHERE room=? AND pinHash=? AND start BETWEEN ? AND ?
     ORDER BY start ASC`
  ).bind(String(room), String(pinHash), t0, t1).all();

  const myBookings = (mineRows.results || []).map(mapBookingRow);
  return { bookings, myBookings };
}

/* ================= logs ================= */

async function logEvent(env, actor, action, room, meta) {
  try {
    await env.DB.prepare(`INSERT INTO logs(id,ts,actor,action,room,meta) VALUES(?,?,?,?,?,?)`)
      .bind(
        crypto.randomUUID(),
        Date.now(),
        String(actor || ""),
        String(action || ""),
        String(room || ""),
        JSON.stringify(meta || {})
      ).run();
  } catch {}
}

/* ================= RBAC (minimal snapshot) ================= */

async function getRbacSnapshot(env) {
  // Minimal placeholder so Admin UI can render "Funktionen"
  return {
    roles: ["sa","admin","ps","sv","user"],
    perms: {
      sa: ["*"],
      admin: ["admin.config","admin.machines","admin.rooms","admin.logs","admin.bookings","admin.users"],
      ps: ["portal.view","portal.book","portal.release","portal.defect"],
      sv: ["portal.view","portal.book","portal.release","portal.defect"],
      user: ["portal.view","portal.book","portal.release","portal.defect"]
    }
  };
}

/* ================= PBKDF2 helpers ================= */

function b64uToBytes(s) {
  s = String(s).replace(/-/g, "+").replace(/_/g, "/");
  while (s.length % 4) s += "=";
  const bin = atob(s);
  const out = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
  return out;
}
function bytesToB64u(bytes) {
  let bin = "";
  bytes.forEach(b => (bin += String.fromCharCode(b)));
  return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
async function hashPbkdf2(pin) {
  const iter = 50000;
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const key = await crypto.subtle.importKey("raw", new TextEncoder().encode(pin), "PBKDF2", false, ["deriveBits"]);
  const bits = await crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-256", salt, iterations: iter }, key, 256);
  return `pbkdf2_sha256$${iter}$${bytesToB64u(salt)}$${bytesToB64u(new Uint8Array(bits))}`;
}
async function verifyPbkdf2(pin, stored) {
  try {
    const parts = String(stored).split("$");
    if (parts.length !== 4) return false;
    const iter = toInt(parts[1], 0);
    const salt = b64uToBytes(parts[2]);
    const want = String(parts[3]);
    const key = await crypto.subtle.importKey("raw", new TextEncoder().encode(pin), "PBKDF2", false, ["deriveBits"]);
    const bits = await crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-256", salt, iterations: iter }, key, 256);
    const got = bytesToB64u(new Uint8Array(bits));
    return timingSafeEq(got, want);
  } catch {
    return false;
  }
}
function timingSafeEq(a, b) {
  a = String(a); b = String(b);
  if (a.length !== b.length) return false;
  let r = 0;
  for (let i = 0; i < a.length; i++) r |= a.charCodeAt(i) ^ b.charCodeAt(i);
  return r === 0;
}
