export default {
  async fetch(request, env) {
    const BUILD_ID = "WASHPORTAL-ALPHA-2026-02-05-AUTHFIX";
    const url = new URL(request.url);

    // -----------------------------
    // CORS + preflight
    // -----------------------------
    if (request.method === "OPTIONS") {
        return new Response("", { status: 204, headers: corsHeaders() });
    }

    // -----------------------------
    // HARD: status (no DB needed)
    // -----------------------------
// -----------------------------
// HARD: DB check (proves D1 binding works)
// -----------------------------
// -----------------------------
    // Schema (D1)
    // -----------------------------
    try {
      await ensureSchema(env);
    } catch (e) {
        return corsJson({ ok: false, error: "internal_error", message: String(e?.message || e), build: BUILD_ID }, 500);
    }

    // add column for optional privacy transition (safe on existing DB)
try {
  await env.DB.prepare(`ALTER TABLE auth_users ADD COLUMN privacyVisibleUntil INTEGER NOT NULL DEFAULT 0`).run();
} catch(e) {
  // ignore "duplicate column" errors
}

// add column for auth password hash (safe on existing DB)
try {
  await env.DB.prepare(`ALTER TABLE auth_users ADD COLUMN passwordHash TEXT NOT NULL DEFAULT ''`).run();
} catch(e) {
  // ignore "duplicate column" errors
}


    // -----------------------------
    // ROUTER
    // -----------------------------
    try {

// ---- HEALTH: status ----
// GET /api/_status
if (request.method === "GET" && url.pathname === "/api/_status") {
        return corsJson({ ok: true, build: BUILD_ID, now: Date.now() }, 200);
}
      // ---- PUBLIC: Registrierung (ps / stellv. ps / admin) ----
      // POST /api/ps/register {firstName,lastName,email,role,password}
      if (request.method === "POST" && url.pathname === "/api/ps/register") {
        const body = await request.json().catch(() => ({}));
        const firstName = String(body.firstName || "").trim();
        const lastName  = String(body.lastName  || "").trim();
        const email     = String(body.email     || "").trim().toLowerCase();
        const role      = String(body.role || "ps").trim(); // ps | ps_deputy | admin
        const password  = String(body.password  || "").trim();

        const allowedRoles = new Set(["ps", "ps_deputy", "admin"]);
        if (!allowedRoles.has(role)) {
        return corsJson({ ok: false, error: "bad_request", message: "Rolle ung√ºltig", build: BUILD_ID }, 400);
        }
        if (!firstName || !lastName || !email || !email.includes("@")) {
        return corsJson({ ok: false, error: "bad_request", message: "Vorname, Nachname und Email erforderlich", build: BUILD_ID }, 400);
        }
        if (!password || password.length < 8) {
        return corsJson({ ok: false, error: "bad_request", message: "Passwort erforderlich (mind. 8 Zeichen)", build: BUILD_ID }, 400);
        }

        const existing = await env.DB.prepare(
          `SELECT id,status,role,passwordHash FROM auth_users WHERE email=? LIMIT 1`
        ).bind(email).first();

        if (existing) {
          // allow "set password" if the user exists but has no password yet
          const ph = String(existing.passwordHash || "");
          if (!ph) {
            const passwordHash = await hashPassword(password, 50000);
            await env.DB.prepare(`UPDATE auth_users SET passwordHash=? WHERE id=?`).bind(passwordHash, existing.id).run();
            await logEvent(env, "system", "auth_password_set_on_register", "system", { email, role: existing.role });
            return corsJson({ ok: true, note: "password_set", status: existing.status, role: existing.role, build: BUILD_ID }, 200);
          }
          return corsJson({ ok: true, note: "already_exists", status: existing.status, role: existing.role, build: BUILD_ID }, 200);
        }


        const now = Date.now();
        const id = crypto.randomUUID();

        const passwordHash = await hashPassword(password, 50000);

        await env.DB.prepare(`
          INSERT INTO auth_users(
            id, role, firstName, lastName, email, passwordHash, status, createdAt, approvedAt, approvedBy, privacyVisibleUntil
          )
          VALUES(
            ?, ?, ?, ?, ?, ?, 'pending', ?, 0, '', 0
          )
        `).bind(id, role, firstName, lastName, email, passwordHash, now).run();

        await logEvent(env, "system", "auth_register", "system", { email, role });

        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }
// ---- PUBLIC: Privacy Meta ----
      // GET /api/privacy/meta
      if (request.method === "GET" && url.pathname === "/api/privacy/meta") {
        const cfg = await getConfig(env);
        const now = Date.now();

        const daysPast = Number(cfg?.daysPast || 0);
        const daysFuture = Number(cfg?.daysFuture || 0);
        const deleteAt = now + daysFuture * 24 * 60 * 60 * 1000;

          // Datenschutz: NUR aktiver Patientensprecher (Stellvertreter NICHT anzeigen)
  const psRows = await env.DB.prepare(`
  SELECT firstName,lastName,email,status,createdAt
  FROM auth_users
  WHERE role='ps' AND status='active'
  ORDER BY approvedAt DESC, createdAt DESC
  LIMIT 5
`).all();

const patientSpeakers = (psRows.results || []).map(x => ({
  name: `${x.firstName || ""} ${x.lastName || ""}`.trim(),
  emailMasked: maskEmail(x.email),
  status: x.status,
  createdAt: x.createdAt
}));


        return corsJson({
          ok: true,
          daysPast,
          daysFuture,
          deleteAt,
          patientSpeakers,
          build: BUILD_ID
        }, 200);
      }

      // ---- PUBLIC: Patientensprecher Login via Code (Magic Code) ----
      // POST /api/ps/login {email, password}  (oder Fallback: {email, code})
      if (request.method === "POST" && url.pathname === "/api/ps/login") {
        const body = await request.json().catch(() => ({}));
        const email = String(body.email || "").trim().toLowerCase();
        const password = String(body.password || "").trim();
        const code  = String(body.code  || "").trim();

        if (!email || (!password && !code)) {
        return corsJson({ ok: false, error: "bad_request", message: "Email + Passwort (oder Code) erforderlich", build: BUILD_ID }, 400);
        }

        const u = await env.DB.prepare(`
          SELECT id,email,role,status,passwordHash
          FROM auth_users
          WHERE email=? AND role IN ('ps','ps_deputy','admin')
          LIMIT 1
        `).bind(email).first();

        if (!u || u.status !== "active") {
        return corsJson({ ok: false, error: "forbidden", message: "Nicht freigeschaltet", build: BUILD_ID }, 403);
        }

        const now = Date.now();

        // ---- primary: password login ----
        if (password) {
          const ph = String(u.passwordHash || "");
          if (!ph) {
        return corsJson({ ok: false, error: "forbidden", message: "Passwort nicht gesetzt (Admin: Login-Code nutzen und Passwort setzen)", build: BUILD_ID }, 403);
          }
          const ok = await verifyPassword(password, ph);
          if (!ok) {
        return corsJson({ ok: false, error: "forbidden", message: "Passwort falsch", build: BUILD_ID }, 403);
          }
        } else {
          // ---- fallback: code login ----
          const rows = await env.DB.prepare(`
            SELECT id,codeHash,expiresAt
            FROM auth_login_codes
            WHERE userId=? AND expiresAt>?
            ORDER BY createdAt DESC
            LIMIT 20
          `).bind(u.id, now).all();

          let match = null;
          for (const r of (rows.results || [])) {
            const h = await sha256Hex(`${u.email}|${code}|${r.expiresAt}`);
            if (h === r.codeHash) { match = r; break; }
          }
          if (!match) {
        return corsJson({ ok: false, error: "forbidden", message: "Code ung√ºltig oder abgelaufen", build: BUILD_ID }, 403);
          }

          // one-time: code l√∂schen
          await env.DB.prepare(`DELETE FROM auth_login_codes WHERE id=?`).bind(match.id).run();
        }

        const token = crypto.randomUUID() + crypto.randomUUID().replace(/-/g, "");
        const tokenHash = await sha256Hex(token);
        const expiresAt = now + 7 * 24 * 60 * 60 * 1000; // 7 Tage

        const role = String(u.role || "ps");

        // store session (role column may not exist on older DBs)
        try {
          await env.DB.prepare(`
            INSERT OR REPLACE INTO auth_sessions(tokenHash,userId,role,expiresAt,createdAt)
            VALUES(?,?,?,?,?)
          `).bind(tokenHash, u.id, role, expiresAt, now).run();
        } catch (e) {
          // fallback for very old schema without role column
          await env.DB.prepare(`
            INSERT OR REPLACE INTO auth_sessions(tokenHash,userId,expiresAt,createdAt)
            VALUES(?,?,?,?)
          `).bind(tokenHash, u.id, expiresAt, now).run();
        }

        return corsJson({ ok: true, token, role, expiresAt, build: BUILD_ID }, 200);
      }

      // POST /api/auth/password/change  (PS/SV/Admin logged in)
      // header: Authorization: Bearer <token>
      // body: {newPassword}
      if (request.method === "POST" && url.pathname === "/api/auth/password/change") {
        const auth = await authFromRequest(request, env);
        if (!auth) return corsJson({ ok:false, error:"forbidden", message:"Nicht angemeldet", build: BUILD_ID }, 403);

        const body = await request.json().catch(() => ({}));
        const newPassword = String(body.newPassword || "").trim();

        if (!newPassword || newPassword.length < 8) {
        return corsJson({ ok:false, error:"bad_request", message:"Neues Passwort (mind. 8 Zeichen) erforderlich", build: BUILD_ID }, 400);
        }

        // only for auth roles
        const r = String(auth.user?.role || "");
        if (!["ps","ps_deputy","admin","super_admin"].includes(r)) {
        return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);
        }

        const h = await hashPassword(newPassword, 50000);
        await env.DB.prepare(`UPDATE auth_users SET passwordHash=? WHERE id=?`).bind(h, auth.user.id).run();
        await logEvent(env, "auth", "password_changed", auth.user.email || "user", { userId: auth.user.id, role: r });

        return corsJson({ ok:true, build: BUILD_ID }, 200);
      }
// ---- USER: refresh ----
      // POST /api/user/refresh {room,pin,stationPin}
      if (request.method === "POST" && url.pathname === "/api/user/refresh") {
        const body = await request.json().catch(() => ({}));
        const room = normRoom(body.room);
        const pin = normPin(body.pin);
        const stationPin = normPin(body.stationPin);

        if (!room || !pin || !stationPin) {
        return corsJson({ ok: false, error: "bad_request", message: "Zimmer, PIN, Stations-PIN erforderlich", build: BUILD_ID }, 400);
        }

        if (!(await checkStationPin(env, stationPin))) {
        return corsJson({ ok: false, error: "forbidden", message: "Stations-PIN falsch", build: BUILD_ID }, 403);
        }
        if (!(await ensureRoomAuth(env, room, pin))) {
        return corsJson({ ok: false, error: "forbidden", message: "PIN falsch", build: BUILD_ID }, 403);}

        const pinHash = await getRoomPinHash(env, room, pin);

        // room control (blocked/message) is independent of PIN
const rcRow = await env.DB.prepare(
  `SELECT blocked,message FROM room_controls WHERE room=? LIMIT 1`
).bind(room).first();
        const roomControl = rcRow ? { blocked: !!rcRow.blocked, message: rcRow.message || "" } : { blocked: false, message: "" };

        const cfg = await getConfig(env);

        // time window in ms
        const now = Date.now();
        const win = computeTimeWindow(now, cfg.daysPast, cfg.daysFuture);

        const machines = await listMachines(env);

        // bookings in window
        const bookings = await env.DB.prepare(
          `SELECT id,type,machine,start,end,room,status,createdAt,cancelledAt,releasedAt
           FROM bookings
           WHERE end >= ? AND start <= ?
           ORDER BY start ASC`
        ).bind(win.from, win.to).all();

        // üëá NUR MEINE BUCHUNGEN (room + pinHash)
const my = await env.DB.prepare(
  `SELECT id,type,machine,start,end,room,status,createdAt,cancelledAt,releasedAt
   FROM bookings
   WHERE room=? AND pinHash=? AND end >= ? AND start <= ?
   ORDER BY start ASC`
).bind(room, pinHash, win.from, win.to).all();

const myBookings = my.results || [];


        // feedback thread summary for this room
        const thread = await env.DB.prepare(
          `SELECT id,allowUserView,userUnread,adminUnread,updatedAt
           FROM feedback_threads
           WHERE room=? AND pinHash=? LIMIT 1`
        ).bind(room, pinHash).first();

        // news seen?
        let newsSeen = true;
        if (cfg.newsEnabled && cfg.newsVersion > 0) {
          const seen = await env.DB.prepare(
            `SELECT 1 AS one FROM news_seen WHERE room=? AND pinHash=? AND newsVersion=? LIMIT 1`
          ).bind(room, pinHash, cfg.newsVersion).first();
          newsSeen = !!seen;
        }

        const resp = {
          ok: true,
          build: BUILD_ID,
          now,
          config: cfg,
          window: win,
          machines,
          bookings: bookings.results || [],
          myBookings,
          feedback: thread ? {
            hasThread: true,
            allowUserView: !!thread.allowUserView,
            userUnread: !!thread.userUnread,
            adminUnread: !!thread.adminUnread,
            updatedAt: Number(thread.updatedAt || 0),
          } : { hasThread: false, allowUserView: true, userUnread: false, adminUnread: false, updatedAt: 0 },
          news: {
            enabled: !!cfg.newsEnabled,
            text: cfg.newsText || "",
            version: Number(cfg.newsVersion || 0),
            seen: newsSeen,
          },
          roomControl
        };

        return corsJson(resp, 200);
      }

      // ---- USER: washer book ----
      // POST /api/washer/book {room,pin,stationPin,machine,start,end}
      if (request.method === "POST" && url.pathname === "/api/washer/book") {
        const body = await request.json().catch(() => ({}));
        const room = normRoom(body.room);
        const pin = normPin(body.pin);
        const stationPin = normPin(body.stationPin);
        const machine = normMachine(body.machine, 4);
        const start = Number(body.start);
        const end = Number(body.end);

        if (!room || !pin || !stationPin || !machine || !Number.isFinite(start) || !Number.isFinite(end)) {
        return corsJson({ ok: false, error: "bad_request", message: "Parameter fehlen", build: BUILD_ID }, 400);
        }
        if (!(await checkStationPin(env, stationPin))) return corsJson({ ok: false, error: "forbidden", message: "Stations-PIN falsch", build: BUILD_ID }, 403);
        if (!(await ensureRoomAuth(env, room, pin))) return corsJson({ ok: false, error: "forbidden", message: "PIN falsch", build: BUILD_ID }, 403);

        // room may be blocked (independent of PIN)
        const rc = await env.DB.prepare(`SELECT blocked FROM room_controls WHERE room=? LIMIT 1`).bind(room).first();
        if (rc && Number(rc.blocked||0) === 1) {
        return corsJson({ ok: false, error: "blocked", message: "Zimmer ist gesperrt", build: BUILD_ID }, 403);
        }
        const pinHash = await getRoomPinHash(env, room, pin);

        // room control (blocked/message) is independent of PIN
        const rcRow = await env.DB.prepare(
          `SELECT blocked,message FROM room_controls WHERE room=? LIMIT 1`
        ).bind(room).first();
        const roomControl = rcRow ? { blocked: !!rcRow.blocked, message: rcRow.message || "" } : { blocked: false, message: "" };

        const cfg = await getConfig(env);
        const now = Date.now();

        // washers: allow booking if end>now (slot not fully past)
        if (!(end > now)) {
        return corsJson({ ok: false, error: "slot_past", message: "Vergangene Slots k√∂nnen nicht gebucht werden", build: BUILD_ID }, 409);
        }

        // machine enabled & not defect
        const m = await getMachine(env, "washer", machine);
        if (!m || !m.enabled) return corsJson({ ok: false, error: "machine_disabled", message: "Maschine gesperrt", build: BUILD_ID }, 409);
        if (m.defect) return corsJson({ ok: false, error: "machine_defect", message: "Maschine ist defekt", build: BUILD_ID }, 409);

        // Overbooking protection: conflict with active booked overlap
        const conf = await env.DB.prepare(
          `SELECT id,room,start,end
           FROM bookings
           WHERE type='washer' AND machine=? AND status='booked'
             AND NOT (end <= ? OR start >= ?)
           LIMIT 1`
        ).bind(machine, start, end).first();

        if (conf) {
        return corsJson({ ok: false, error: "overbook", message: "Slot ist belegt", conflict: conf, build: BUILD_ID }, 409);
        }

        const id = crypto.randomUUID();
        const createdAt = now;

        await env.DB.prepare(
          `INSERT INTO bookings(id,type,machine,start,end,room,pinHash,status,createdAt,cancelledAt,releasedAt)
           VALUES(?,?,?,?,?,?,?,?,?,?,?)`
        ).bind(id, "washer", machine, start, end, room, pinHash, "booked", createdAt, 0, 0).run();

        // update machine lastRoom
        await setLastRoom(env, "washer", machine, room);

        await logEvent(env, "user", "washer_book", room, { machine, start, end, id });

        return corsJson({ ok: true, id, build: BUILD_ID }, 200);
      }

      // ---- USER: dryer book ----
      // POST /api/dryer/book {room,pin,stationPin,machine,force:boolean,confirmed:boolean}
      // dryer booking starts NOW, duration from config (60/90/120)
      if (request.method === "POST" && url.pathname === "/api/dryer/book") {
        const body = await request.json().catch(() => ({}));
        const room = normRoom(body.room);
        const pin = normPin(body.pin);
        const stationPin = normPin(body.stationPin);
        const machine = normMachine(body.machine, 4);
        const force = !!body.force;
        const confirmed = !!body.confirmed;

        if (!room || !pin || !stationPin || !machine) {
        return corsJson({ ok: false, error: "bad_request", message: "Parameter fehlen", build: BUILD_ID }, 400);
        }
        if (!(await checkStationPin(env, stationPin))) return corsJson({ ok: false, error: "forbidden", message: "Stations-PIN falsch", build: BUILD_ID }, 403);
        if (!(await ensureRoomAuth(env, room, pin))) return corsJson({ ok: false, error: "forbidden", message: "PIN falsch", build: BUILD_ID }, 403);

        // room may be blocked (independent of PIN)
        const rc = await env.DB.prepare(`SELECT blocked FROM room_controls WHERE room=? LIMIT 1`).bind(room).first();
        if (rc && Number(rc.blocked||0) === 1) {
        return corsJson({ ok: false, error: "blocked", message: "Zimmer ist gesperrt", build: BUILD_ID }, 403);
        }
        const pinHash = await getRoomPinHash(env, room, pin);

        // room control (blocked/message) is independent of PIN
        const rcRow = await env.DB.prepare(
          `SELECT blocked,message FROM room_controls WHERE room=? LIMIT 1`
        ).bind(room).first();
        const roomControl = rcRow ? { blocked: !!rcRow.blocked, message: rcRow.message || "" } : { blocked: false, message: "" };

        const cfg = await getConfig(env);
        const now = Date.now();

        const m = await getMachine(env, "dryer", machine);
        if (!m || !m.enabled) return corsJson({ ok: false, error: "machine_disabled", message: "Trockner gesperrt", build: BUILD_ID }, 409);
        if (m.defect) return corsJson({ ok: false, error: "machine_defect", message: "Trockner ist defekt", build: BUILD_ID }, 409);

        const start = now;
        const end = now + (Number(cfg.dryerMinutes) || 120) * 60 * 1000;

        // conflict with running booking
        const running = await env.DB.prepare(
          `SELECT id,room,start,end,status
           FROM bookings
           WHERE type='dryer' AND machine=? AND status='booked'
             AND start <= ? AND end > ?
           LIMIT 1`
        ).bind(machine, now, now).first();

        if (running && !force) {
        return corsJson({
            ok: false,
            error: "dryer_busy",
            message: "Trockner l√§uft noch. √úberbuchen nur nach Best√§tigung m√∂glich.",
            requiresConfirm: true,
            build: BUILD_ID,
          }, 409);
        }

        if (running && force) {
          if (!confirmed) {
        return corsJson({
              ok: false,
              error: "confirm_required",
              message: "Bitte best√§tige: W√§sche vom Vorg√§nger ist sauber und im Korb abgelegt.",
              requiresConfirm: true,
              build: BUILD_ID,
            }, 409);
          }

          // release previous booking (not cancel)
          const relNow = now;
          await env.DB.prepare(
            `UPDATE bookings SET end=?, status='released', releasedAt=? WHERE id=?`
          ).bind(relNow, relNow, running.id).run();

          await logEvent(env, "user", "dryer_overbook_release_prev", room, { machine, prevId: running.id });
        }

        // create booking
        const id = crypto.randomUUID();
        await env.DB.prepare(
          `INSERT INTO bookings(id,type,machine,start,end,room,pinHash,status,createdAt,cancelledAt,releasedAt)
           VALUES(?,?,?,?,?,?,?,?,?,?,?)`
        ).bind(id, "dryer", machine, start, end, room, pinHash, "booked", now, 0, 0).run();

        await setLastRoom(env, "dryer", machine, room);
        await logEvent(env, "user", "dryer_book", room, { machine, start, end, id });

        return corsJson({ ok: true, id, start, end, build: BUILD_ID }, 200);
      }

      // ---- USER: cancel (only if slot NOT started) ----
      // POST /api/booking/cancel {room,pin,id}
      if (request.method === "POST" && url.pathname === "/api/booking/cancel") {
        const body = await request.json().catch(() => ({}));
        const room = normRoom(body.room);
        const pin = normPin(body.pin);
        const id = String(body.id || "");

        if (!room || !pin || !id) return corsJson({ ok: false, error: "bad_request", build: BUILD_ID }, 400);
        if (!(await ensureRoomAuth(env, room, pin))) {
        return corsJson({ ok: false, error: "forbidden", message: "PIN falsch", build: BUILD_ID }, 403);
        }
        const pinHash = await getRoomPinHash(env, room, pin);

        // room control (blocked/message) is independent of PIN
        const rcRow = await env.DB.prepare(
          `SELECT blocked,message FROM room_controls WHERE room=? LIMIT 1`
        ).bind(room).first();
        const roomControl = rcRow ? { blocked: !!rcRow.blocked, message: rcRow.message || "" } : { blocked: false, message: "" };
        const b = await env.DB.prepare(
          `SELECT id,type,machine,start,end,room,status
           FROM bookings
           WHERE id=? AND room=? AND pinHash=? LIMIT 1`
        ).bind(id, room, pinHash).first();

        if (!b) return corsJson({ ok: false, error: "not_found", build: BUILD_ID }, 404);
        if (b.status !== "booked") return corsJson({ ok: false, error: "not_booked", build: BUILD_ID }, 409);

        const now = Date.now();
        if (!(now < Number(b.start))) {
        return corsJson({ ok: false, error: "already_started", message: "Storno nur vor Start m√∂glich", build: BUILD_ID }, 409);
        }

        // dryers: not cancellable (per requirements)
        if (b.type === "dryer") {
        return corsJson({ ok: false, error: "not_allowed", message: "Trockner k√∂nnen nicht storniert werden. Bitte 'Freigeben' nutzen.", build: BUILD_ID }, 409);
        }

        await env.DB.prepare(
          `UPDATE bookings SET status='cancelled', cancelledAt=? WHERE id=?`
        ).bind(now, id).run();

        await logEvent(env, "user", "booking_cancel", room, { type: b.type, machine: b.machine, id });

        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }

      // ---- USER: release (only if slot running) ----
      // POST /api/booking/release {room,pin,id}
      if (request.method === "POST" && url.pathname === "/api/booking/release") {
        const body = await request.json().catch(() => ({}));
        const room = normRoom(body.room);
        const pin = normPin(body.pin);
        const id = String(body.id || "");

        if (!room || !pin || !id) return corsJson({ ok: false, error: "bad_request", build: BUILD_ID }, 400);
        if (!(await ensureRoomAuth(env, room, pin))) {
        return corsJson({ ok: false, error: "forbidden", message: "PIN falsch", build: BUILD_ID }, 403);
      }
        const pinHash = await getRoomPinHash(env, room, pin);

        // room control (blocked/message) is independent of PIN
        const rcRow = await env.DB.prepare(
          `SELECT blocked,message FROM room_controls WHERE room=? LIMIT 1`
        ).bind(room).first();
        const roomControl = rcRow ? { blocked: !!rcRow.blocked, message: rcRow.message || "" } : { blocked: false, message: "" };
        const b = await env.DB.prepare(
          `SELECT id,type,machine,start,end,room,status
           FROM bookings
           WHERE id=? AND room=? AND pinHash=? LIMIT 1`
        ).bind(id, room, pinHash).first();

        if (!b) return corsJson({ ok: false, error: "not_found", build: BUILD_ID }, 404);
        if (b.status !== "booked") return corsJson({ ok: false, error: "not_booked", build: BUILD_ID }, 409);

        const now = Date.now();
        if (!(Number(b.start) <= now && Number(b.end) > now)) {
        return corsJson({ ok: false, error: "not_running", message: "Freigeben nur wenn Slot l√§uft", build: BUILD_ID }, 409);
        }

        await env.DB.prepare(
          `UPDATE bookings SET end=?, status='released', releasedAt=? WHERE id=?`
        ).bind(now, now, id).run();

        await setLastRoom(env, b.type, b.machine, room);
        await logEvent(env, "user", "booking_release", room, { type: b.type, machine: b.machine, id });

        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }

      // ---- USER: defect report (allowed by config and per-machine) ----
      // POST /api/defect/report {room,pin,stationPin,type, ‡§Æ‡§∂‡•Ä‡§®, defect:boolean}
      if (request.method === "POST" && url.pathname === "/api/defect/report") {
        const body = await request.json().catch(() => ({}));
        const room = normRoom(body.room);
        const pin = normPin(body.pin);
        const stationPin = normPin(body.stationPin);
        const type = normType(body.type);
        const machine = normMachine(body.machine, 4);
        const defect = !!body.defect;

        if (!room || !pin || !stationPin || !type || !machine) {
        return corsJson({ ok: false, error: "bad_request", build: BUILD_ID }, 400);
        }
        if (!(await checkStationPin(env, stationPin))) return corsJson({ ok: false, error: "forbidden", message: "Stations-PIN falsch", build: BUILD_ID }, 403);
        //if (!(await ensureRoomAuth(env, room, pin))) return corsJson({ ok: false, error: "forbidden", message: "PIN falsch", build: BUILD_ID }, 403);

        const cfg = await getConfig(env);
        if (!cfg.userDefectEnabled) {
        return corsJson({ ok: false, error: "not_allowed", message: "Defektmeldung ist deaktiviert", build: BUILD_ID }, 409);
        }
        const allowed = !!(cfg.userDefectAllowed?.[type]?.[String(machine)]);
        if (!allowed) {
        return corsJson({ ok: false, error: "not_allowed", message: "Defektmeldung f√ºr diese Maschine ist deaktiviert", build: BUILD_ID }, 409);
        }

        const now = Date.now();
        await setDefect(env, type, machine, defect ? 1 : 0, defect ? `Zimmer ${room}` : "", defect ? now : 0);
        await logEvent(env, "user", defect ? "defect_set" : "defect_clear", room, { type, machine });

        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }

      // ---- USER: news seen ----
      // POST /api/news/seen {room,pin,stationPin}
      if (request.method === "POST" && url.pathname === "/api/news/seen") {
        const body = await request.json().catch(() => ({}));
        const room = normRoom(body.room);
        const pin = normPin(body.pin);
        const stationPin = normPin(body.stationPin);
        if (!room || !pin || !stationPin) return corsJson({ ok: false, error: "bad_request", build: BUILD_ID }, 400);
        if (!(await checkStationPin(env, stationPin))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
        if (!(await ensureRoomAuth(env, room, pin))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);

        const cfg = await getConfig(env);
        if (!cfg.newsEnabled || !cfg.newsVersion) {
        return corsJson({ ok: true, build: BUILD_ID, note: "news disabled" }, 200);
        }

        const pinHash = await getRoomPinHash(env, room, pin);

        // room control (blocked/message) is independent of PIN
        const rcRow = await env.DB.prepare(
          `SELECT blocked,message FROM room_controls WHERE room=? LIMIT 1`
        ).bind(room).first();
        const roomControl = rcRow ? { blocked: !!rcRow.blocked, message: rcRow.message || "" } : { blocked: false, message: "" };
        await env.DB.prepare(
          `INSERT OR IGNORE INTO news_seen(room,pinHash,newsVersion,ts) VALUES(?,?,?,?)`
        ).bind(room, pinHash, Number(cfg.newsVersion), Date.now()).run();

        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }

      // ---- USER: feedback send ----
      // POST /api/feedback/send {room,pin,stationPin,message}
      if (request.method === "POST" && url.pathname === "/api/feedback/send") {
        const body = await request.json().catch(() => ({}));
        const room = normRoom(body.room);
        const pin = normPin(body.pin);
        const stationPin = normPin(body.stationPin);
        const message = String(body.message || "").trim();

        if (!room || !pin || !stationPin || !message) {
        return corsJson({ ok: false, error: "bad_request", message: "Daten fehlen", build: BUILD_ID }, 400);
        }
        if (!(await checkStationPin(env, stationPin))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
        if (!(await ensureRoomAuth(env, room, pin))) {
        return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
      }
        const pinHash = await getRoomPinHash(env, room, pin);

        // room control (blocked/message) is independent of PIN
        const rcRow = await env.DB.prepare(
          `SELECT blocked,message FROM room_controls WHERE room=? LIMIT 1`
        ).bind(room).first();
        const roomControl = rcRow ? { blocked: !!rcRow.blocked, message: rcRow.message || "" } : { blocked: false, message: "" };
        const now = Date.now();

        let thread = await env.DB.prepare(
          `SELECT id,allowUserView FROM feedback_threads WHERE room=? AND pinHash=? LIMIT 1`
        ).bind(room, pinHash).first();

        let threadId = thread?.id;
        if (!threadId) {
          threadId = crypto.randomUUID();
          await env.DB.prepare(
            `INSERT INTO feedback_threads(id,room,pinHash,createdAt,updatedAt,lastUserAt,lastAdminAt,userUnread,adminUnread,allowUserView)
             VALUES(?,?,?,?,?,?,?,?,?,?)`
          ).bind(threadId, room, pinHash, now, now, now, 0, 0, 1, 1).run();
        } else {
          await env.DB.prepare(
            `UPDATE feedback_threads SET updatedAt=?, lastUserAt=?, adminUnread=1 WHERE id=?`
          ).bind(now, now, threadId).run();
        }

        const msgId = crypto.randomUUID();
        await env.DB.prepare(
          `INSERT INTO feedback_msgs(id,threadId,sender,message,ts,visibleToUser,readByUser,readByAdmin)
           VALUES(?,?,?,?,?,?,?,?)`
        ).bind(msgId, threadId, "user", message, now, 1, 1, 0).run(); // user wrote -> readByUser true, admin unread

        await logEvent(env, "user", "feedback_send", room, { threadId, msgId });

        return corsJson({ ok: true, threadId, msgId, build: BUILD_ID }, 200);
      }

      // ---- USER: feedback load ----
      // POST /api/feedback/load {room,pin,stationPin}
      if (request.method === "POST" && url.pathname === "/api/feedback/load") {
        const body = await request.json().catch(() => ({}));
        const room = normRoom(body.room);
        const pin = normPin(body.pin);
        const stationPin = normPin(body.stationPin);

        if (!room || !pin || !stationPin) return corsJson({ ok: false, error: "bad_request", build: BUILD_ID }, 400);
        if (!(await checkStationPin(env, stationPin))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
        if (!(await ensureRoomAuth(env, room, pin))) {
        return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
      }
        const pinHash = await getRoomPinHash(env, room, pin);

        // room control (blocked/message) is independent of PIN
        const rcRow = await env.DB.prepare(
          `SELECT blocked,message FROM room_controls WHERE room=? LIMIT 1`
        ).bind(room).first();
        const roomControl = rcRow ? { blocked: !!rcRow.blocked, message: rcRow.message || "" } : { blocked: false, message: "" };

        const thread = await env.DB.prepare(
          `SELECT id,allowUserView,userUnread,adminUnread,updatedAt FROM feedback_threads WHERE room=? AND pinHash=? LIMIT 1`
        ).bind(room, pinHash).first();

        if (!thread) {
        return corsJson({ ok: true, hasThread: false, messages: [], build: BUILD_ID }, 200);
        }

        const msgs = await env.DB.prepare(
          `SELECT id,threadId,sender,message,ts,visibleToUser,readByUser,readByAdmin
           FROM feedback_msgs
           WHERE threadId=?
           ORDER BY ts ASC`
        ).bind(thread.id).all();

        // mark as read by user (only those visible)
        await env.DB.prepare(
          `UPDATE feedback_msgs SET readByUser=1 WHERE threadId=? AND visibleToUser=1`
        ).bind(thread.id).run();
        await env.DB.prepare(
          `UPDATE feedback_threads SET userUnread=0 WHERE id=?`
        ).bind(thread.id).run();

        const filtered = (msgs.results || []).filter(m => m.visibleToUser === 1);

        return corsJson({
          ok: true,
          hasThread: true,
          allowUserView: !!thread.allowUserView,
          messages: filtered,
          build: BUILD_ID,
        }, 200);
      }

            // -----------------------------
      // PRIVACY META (for /privacy page)
      // -----------------------------
// -----------------------------
      // PATIENT SPEAKER REGISTRATION + LOGIN
      // -----------------------------

      // POST /api/auth/login {email, code}
      if (request.method === "POST" && url.pathname === "/api/auth/login") {
        const body = await request.json().catch(() => ({}));
        const email = String(body.email || "").trim().toLowerCase();
        const code  = String(body.code  || "").trim();
        const password = String(body.password || "").trim();

        if (!email || !code) {
        return corsJson({ ok:false, error:"bad_request", message:"E-Mail und Code erforderlich.", build: BUILD_ID }, 400);
        }

        const user = await env.DB.prepare(
          `SELECT id,role,status,firstName,lastName,email FROM auth_users WHERE email=? LIMIT 1`
        ).bind(email).first();

        if (!user) return corsJson({ ok:false, error:"forbidden", message:"Login fehlgeschlagen.", build: BUILD_ID }, 403);
        if (user.status !== "active") return corsJson({ ok:false, error:"forbidden", message:"Account noch nicht freigeschaltet.", build: BUILD_ID }, 403);

        const now = Date.now();

        // newest unused code for user
        const row = await env.DB.prepare(
          `SELECT id,codeHash,expiresAt,usedAt FROM auth_login_codes
           WHERE userId=? ORDER BY createdAt DESC LIMIT 1`
        ).bind(user.id).first();

        if (!row || row.usedAt) return corsJson({ ok:false, error:"forbidden", message:"Code ung√ºltig oder abgelaufen.", build: BUILD_ID }, 403);
        if (now > Number(row.expiresAt || 0)) return corsJson({ ok:false, error:"forbidden", message:"Code abgelaufen.", build: BUILD_ID }, 403);

        const ok = await verifyPassword(code, row.codeHash);
        if (!ok) return corsJson({ ok:false, error:"forbidden", message:"Code ung√ºltig.", build: BUILD_ID }, 403);

        // mark used
        await env.DB.prepare(`UPDATE auth_login_codes SET usedAt=? WHERE id=?`).bind(now, row.id).run();

        const token = await makeSessionToken();
        const tokenHash = await sha256Hex(token);
        const expiresAt = now + 7 * 24 * 60 * 60 * 1000;

        await env.DB.prepare(
          `INSERT INTO auth_sessions(tokenHash,userId,createdAt,expiresAt) VALUES(?,?,?,?)`
        ).bind(tokenHash, user.id, now, expiresAt).run();

        return corsJson({ ok:true, token, user:{ id:user.id, role:user.role, firstName:user.firstName, lastName:user.lastName, email:user.email }, build: BUILD_ID }, 200);
      }

      // GET /api/auth/me  (Authorization: Bearer <token>)
      if ((request.method === "GET" || request.method === "POST") && url.pathname === "/api/auth/me") {
        const au = await authFromRequest(request, env);
        if (!au) return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);
        return corsJson({ ok:true, user: au.user, perms: au.perms, build: BUILD_ID }, 200);
      }


      // POST /api/auth/password/change  (Authorization: Bearer <token>) {oldPassword?, newPassword}
      if (request.method === "POST" && url.pathname === "/api/auth/password/change") {
        const au = await authFromRequest(request, env);
        if (!au) return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);

        const body = await request.json().catch(() => ({}));
        const oldPassword = String(body.oldPassword || "").trim();
        const newPassword = String(body.newPassword || "").trim();

        if (!newPassword || newPassword.length < 6) {
        return corsJson({ ok:false, error:"bad_request", message:"Passwort zu kurz (min. 6)", build: BUILD_ID }, 400);
        }

        const row = await env.DB.prepare(`SELECT passwordHash FROM auth_users WHERE id=? LIMIT 1`).bind(au.user.id).first();
        const currentHash = String(row?.passwordHash || "");
        if (currentHash) {
          const ok = await verifyPassword(oldPassword, currentHash);
          if (!ok) return corsJson({ ok:false, error:"forbidden", message:"Altes Passwort falsch", build: BUILD_ID }, 403);
        }

        const newHash = await hashPassword(newPassword);
        const now = Date.now();
        await env.DB.prepare(`UPDATE auth_users SET passwordHash=?, pwUpdatedAt=? WHERE id=?`).bind(newHash, now, au.user.id).run();

        await logEvent(env, "auth", "password_changed", au.user.email || "", { userId: au.user.id });

        return corsJson({ ok:true, build: BUILD_ID }, 200);
      }

      // -----------------------------
      // ADMIN
      // -----------------------------

      // POST /api/admin/login {adminPassword}
      if (request.method === "POST" && url.pathname === "/api/admin/login") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        if (!pw) return corsJson({ ok: false, error: "bad_request", build: BUILD_ID }, 400);

        const ok = await checkAdminPassword(env, pw);
        if (!ok) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);

        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }

      // POST /api/admin/change-password {adminPassword,newPassword}
      if (request.method === "POST" && url.pathname === "/api/admin/change-password") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const npw = String(body.newPassword || "").trim();
        if (!pw || !npw) return corsJson({ ok: false, error: "bad_request", build: BUILD_ID }, 400);
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);

        const h = await hashPassword(npw, 50000);
        await kvSet(env, "adminPwHash", h);
        await logEvent(env, "admin", "admin_password_changed", "admin", {});
        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }

      // POST /api/admin/set-station-pin {adminPassword,stationPin}
      if (request.method === "POST" && url.pathname === "/api/admin/set-station-pin") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const sp = normPin(body.stationPin);
        if (!pw || !sp) return corsJson({ ok: false, error: "bad_request", message: "PIN muss genau 4-stellig sein", build: BUILD_ID }, 400);
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);

        const h = await hashPassword(sp, 50000);
        await kvSet(env, "stationPinHash", h);
        await logEvent(env, "admin", "station_pin_changed", "admin", {});
        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }

      // -----------------------------
      // ADMIN USER MANAGEMENT (admins + patient speakers)
      // -----------------------------

      // POST /api/admin/auth/users/list {adminPassword}
      if (request.method === "POST" && url.pathname === "/api/admin/auth/users/list") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);

        const users = await env.DB.prepare(
          `SELECT id,role,role2,firstName,lastName,email,status,createdAt,approvedAt,approvedBy,deleteMarkedAt,deleteAfter
           FROM auth_users
           ORDER BY createdAt DESC`
        ).all();

        const perms = await env.DB.prepare(`SELECT permKey,label FROM auth_perms ORDER BY permKey`).all();
        const up = await env.DB.prepare(`SELECT userId,permKey,allowed FROM auth_user_perms`).all();

        return corsJson({ ok:true, users: users.results||[], perms: perms.results||[], userPerms: up.results||[], build: BUILD_ID }, 200);
      }

      // POST /api/admin/auth/users/approve {adminPassword, userId}
      if (request.method === "POST" && url.pathname === "/api/admin/auth/users/approve") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const userId = String(body.userId || "").trim();
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);
        if (!userId) return corsJson({ ok:false, error:"bad_request", message:"userId fehlt", build: BUILD_ID }, 400);

        const now = Date.now();
        await env.DB.prepare(
          `UPDATE auth_users SET status='active', approvedAt=?, approvedBy='super_admin' WHERE id=?`
        ).bind(now, userId).run();

        await logEvent(env, "admin", "auth_user_approve", "", { userId });

        return corsJson({ ok:true, build: BUILD_ID }, 200);
      }

      // POST /api/admin/auth/users/disable {adminPassword, userId, disabled}
      if (request.method === "POST" && url.pathname === "/api/admin/auth/users/disable") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const userId = String(body.userId || "").trim();
        const disabled = !!body.disabled;
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);
        if (!userId) return corsJson({ ok:false, error:"bad_request", message:"userId fehlt", build: BUILD_ID }, 400);

        await env.DB.prepare(
          `UPDATE auth_users SET status=? WHERE id=?`
        ).bind(disabled ? "disabled" : "active", userId).run();

        await logEvent(env, "admin", "auth_user_disable", "", { userId, disabled });

        return corsJson({ ok:true, build: BUILD_ID }, 200);
      }

      // POST /api/admin/auth/users/issue-code {adminPassword, userId}
      // Generates a one-time login code (valid 30 minutes). Share it securely with the user.
      if (request.method === "POST" && url.pathname === "/api/admin/auth/users/issue-code") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const userId = String(body.userId || "").trim();
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);
        if (!userId) return corsJson({ ok:false, error:"bad_request", message:"userId fehlt", build: BUILD_ID }, 400);

        const u = await env.DB.prepare(`SELECT id,status,email FROM auth_users WHERE id=? LIMIT 1`).bind(userId).first();
        if (!u) return corsJson({ ok:false, error:"not_found", build: BUILD_ID }, 404);
        if (u.status !== "active") return corsJson({ ok:false, error:"bad_request", message:"User ist nicht aktiv", build: BUILD_ID }, 400);

        const code = makeShortCode();
        const codeHash = await hashPassword(code, 20000);
        const now = Date.now();
        const expiresAt = now + 30 * 60 * 1000;

        const id = crypto.randomUUID();
        await env.DB.prepare(
          `INSERT INTO auth_login_codes(id,userId,codeHash,createdAt,expiresAt) VALUES(?,?,?,?,?)`
        ).bind(id, userId, codeHash, now, expiresAt).run();

        await logEvent(env, "admin", "auth_issue_code", "", { userId, email: u.email });

        return corsJson({ ok:true, code, expiresAt, build: BUILD_ID }, 200);
      }
      // ---- ADMIN: update user roles + perms ----
      // POST /api/admin/auth/users/update {adminPassword,userId,role1,role2,perms:{permKey:boolean}}
      if (request.method === "POST" && url.pathname === "/api/admin/auth/users/update") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        if (!(await checkAdminPassword(env, pw))) {
        return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
        }

        const userId = String(body.userId || "").trim();
        if (!userId) {
        return corsJson({ ok: false, error: "bad_request", message: "userId fehlt", build: BUILD_ID }, 400);
        }

        const role1 = String(body.role1 || body.role || "").trim();
        const role2 = String(body.role2 || "").trim();
        const allowedRoles = new Set(["admin", "ps", "ps_deputy", ""]);
        if (!allowedRoles.has(role1) || !allowedRoles.has(role2)) {
        return corsJson({ ok: false, error: "bad_request", message: "Ung√ºltige Rolle", build: BUILD_ID }, 400);
        }

        // update roles
        await env.DB.prepare(`UPDATE auth_users SET role=?, role2=? WHERE id=?`)
          .bind(role1, role2, userId).run();

        // update perms
        const permsObj = (body.perms && typeof body.perms === "object") ? body.perms : {};
        await env.DB.prepare(`DELETE FROM auth_user_perms WHERE userId=?`).bind(userId).run();

        // only store known perms (prevents junk keys)
        const known = await env.DB.prepare(`SELECT permKey FROM auth_perms`).all();
        const knownSet = new Set((known.results || []).map(r => r.permKey));

        for (const [k, v] of Object.entries(permsObj)) {
          if (!knownSet.has(k)) continue;
          const allowed = v ? 1 : 0;
          await env.DB.prepare(`INSERT INTO auth_user_perms(userId,permKey,allowed) VALUES(?,?,?)`)
            .bind(userId, k, allowed).run();
        }

        await logEvent(env, "admin", "auth_user_updated", "admin", { userId, role1, role2 });

        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }

      // POST /api/admin/auth/users/deactivate {adminPassword,userId}
      if (request.method === "POST" && url.pathname === "/api/admin/auth/users/deactivate") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const userId = String(body.userId || "").trim();

        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);
        if (!userId) return corsJson({ ok:false, error:"bad_request", build: BUILD_ID }, 400);

        const now = Date.now();

        await env.DB.prepare(`UPDATE auth_users SET status='disabled', deleteMarkedAt=0, deleteAfter=0 WHERE id=?`).bind(userId).run();
        await env.DB.prepare(`DELETE FROM auth_sessions WHERE userId=?`).bind(userId).run();
        await env.DB.prepare(`DELETE FROM auth_login_codes WHERE userId=?`).bind(userId).run();
        await env.DB.prepare(`DELETE FROM auth_user_perms WHERE userId=?`).bind(userId).run();

        await logEvent(env, "admin", "auth_user_deactivated", "admin", { userId });

        return corsJson({ ok:true, build: BUILD_ID }, 200);
      }

      // POST /api/admin/auth/users/mark-delete {adminPassword,userId}
      // marks user for deletion in 14 days; user is disabled immediately (no perms, no sessions)
      if (request.method === "POST" && url.pathname === "/api/admin/auth/users/mark-delete") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const userId = String(body.userId || "").trim();

        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);
        if (!userId) return corsJson({ ok:false, error:"bad_request", build: BUILD_ID }, 400);

        const now = Date.now();
        const deleteAfter = now + 14 * 24 * 60 * 60 * 1000;

        await env.DB.prepare(`UPDATE auth_users SET status='pending_delete', deleteMarkedAt=?, deleteAfter=? WHERE id=?`)
          .bind(now, deleteAfter, userId).run();

        await env.DB.prepare(`DELETE FROM auth_sessions WHERE userId=?`).bind(userId).run();
        await env.DB.prepare(`DELETE FROM auth_login_codes WHERE userId=?`).bind(userId).run();
        await env.DB.prepare(`DELETE FROM auth_user_perms WHERE userId=?`).bind(userId).run();

        await logEvent(env, "admin", "auth_user_mark_delete", "admin", { userId, deleteAfter });

        return corsJson({ ok:true, deleteAfter, build: BUILD_ID }, 200);
      }
      if (request.method === "POST" && url.pathname === "/api/admin/auth/users/set-perm") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const userId = String(body.userId || "").trim();
        const permKey = String(body.permKey || "").trim();
        const allowed = body.allowed ? 1 : 0;

        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok:false, error:"forbidden", build: BUILD_ID }, 403);
        if (!userId || !permKey) return corsJson({ ok:false, error:"bad_request", build: BUILD_ID }, 400);

        await env.DB.prepare(
          `INSERT INTO auth_user_perms(userId,permKey,allowed) VALUES(?,?,?)
           ON CONFLICT(userId,permKey) DO UPDATE SET allowed=excluded.allowed`
        ).bind(userId, permKey, allowed).run();

        return corsJson({ ok:true, build: BUILD_ID }, 200);
      }

            // -----------------------------
// AUTH ADMIN: Config (Bearer)  ‚Äî for PS/VS/Admin via perms
// -----------------------------
// POST /api/auth/admin/config/get
if (request.method === "POST" && url.pathname === "/api/auth/admin/config/get") {
  const au = await authFromRequest(request, env);
  if (!au) return corsJson({ ok:false, error:"forbidden", message:"login_required", build: BUILD_ID }, 403);

  const role = String(au.user?.role || au.role || "");
  const perms = au.perms || {};
  const allowed = (role === "admin" || role === "superadmin" || role === "super_admin" || perms["admin.config.manage"] || perms["admin.news.edit"]);
  if (!allowed) return corsJson({ ok:false, error:"forbidden", message:"no_permission", build: BUILD_ID }, 403);

  const cfg = await getConfig(env);

  // news seen count (current version)
  let seenCount = 0;
  if (cfg.newsEnabled && cfg.newsVersion > 0) {
    const row = await env.DB.prepare(`SELECT COUNT(*) AS c FROM news_seen WHERE newsVersion=?`).bind(cfg.newsVersion).first();
    seenCount = Number(row?.c || 0);
  }

  return corsJson({ ok:true, config: cfg, newsSeenCount: seenCount, build: BUILD_ID }, 200);
}

// POST /api/auth/admin/config/set
if (request.method === "POST" && url.pathname === "/api/auth/admin/config/set") {
  const au = await authFromRequest(request, env);
  if (!au) return corsJson({ ok:false, error:"forbidden", message:"login_required", build: BUILD_ID }, 403);

  const role = String(au.user?.role || au.role || "");
  const perms = au.perms || {};
  const allowed = (role === "admin" || role === "superadmin" || role === "super_admin" || perms["admin.config.manage"] || perms["admin.news.edit"]);
  if (!allowed) return corsJson({ ok:false, error:"forbidden", message:"no_permission", build: BUILD_ID }, 403);

  const body = await request.json().catch(() => ({}));
  const cfg = await getConfig(env);

  // days window
  const daysPast = clampInt(body.daysPast, 0, 30, cfg.daysPast);
  const daysFuture = clampInt(body.daysFuture, 0, 30, cfg.daysFuture);

  // washer hours checkbox list 0..23
  const washerHours = Array.isArray(body.washerHours)
    ? body.washerHours.map(Number).filter(n => Number.isFinite(n) && n >= 0 && n <= 23)
    : cfg.washerHours;
  washerHours.sort((a,b)=>a-b);

  // dryer duration minutes 60/90/120
  const dryerMinutes = [60, 90, 120].includes(Number(body.dryerMinutes)) ? Number(body.dryerMinutes) : cfg.dryerMinutes;

  // defect toggles
  const userDefectEnabled = typeof body.userDefectEnabled === "boolean" ? body.userDefectEnabled : cfg.userDefectEnabled;
  const userDefectAllowed = (body.userDefectAllowed && typeof body.userDefectAllowed === "object") ? body.userDefectAllowed : cfg.userDefectAllowed;

  // news
  const newsEnabled = typeof body.newsEnabled === "boolean" ? body.newsEnabled : cfg.newsEnabled;
  const newsText = typeof body.newsText === "string" ? body.newsText : cfg.newsText;
  let newsVersion = cfg.newsVersion;
  if (body.bumpNewsVersion) newsVersion = Number(cfg.newsVersion || 0) + 1;

  const next = {
    ...cfg,
    daysPast,
    daysFuture,
    washerHours,
    dryerMinutes,
    userDefectEnabled,
    userDefectAllowed,
    newsEnabled,
    newsText,
    newsVersion,
  }
// ---- AUTH: admin users list (Bearer) ----
// POST /api/auth/admin/users/list {includePending?:boolean}
if (request.method === "POST" && url.pathname === "/api/auth/admin/users/list") {
  const auth = await authFromRequest(request, env);
  if (!auth) return corsJson({ ok:false, error:"forbidden", message:"login_required", build: BUILD_ID }, 403);

  const role = String(auth.user?.role || "");
  const perms = auth.perms || {};
  const allowed = (role === "admin" || role === "superadmin" || role === "super_admin" || perms["admin.users.manage"]);
  if (!allowed) return corsJson({ ok:false, error:"forbidden", message:"no_permission", build: BUILD_ID }, 403);

  const body = await request.json().catch(()=> ({}));
  const includePending = body.includePending !== false;

  const rows = await env.DB.prepare(`
    SELECT id,email,role,status,createdAt,approvedAt,approvedBy
    FROM auth_users
    WHERE role IN ('ps','ps_deputy','admin','super_admin','superadmin')
    ${includePending ? "" : "AND status='active'"}
    ORDER BY createdAt DESC
    LIMIT 500
  `).all();

  const ids = (rows?.results || []).map(r=>r.id);
  let permMap = {};
  if (ids.length){
    const qMarks = ids.map(()=>"?").join(",");
    const pr = await env.DB.prepare(`
      SELECT userId, permKey, enabled
      FROM auth_user_perms
      WHERE userId IN (${qMarks})
    `).bind(...ids).all().catch(()=>({results:[]}));
  }

  // D1 prepare().bind doesn't accept splat easily in JS string replace; do it in two steps:
  permMap = {};
  if (ids.length){
    const qMarks2 = ids.map(()=>"?").join(",");
    const stmt = env.DB.prepare(
      `SELECT userId, permKey, enabled FROM auth_user_perms WHERE userId IN (${qMarks2})`
    );
    const pr2 = await stmt.bind(...ids).all();
    for (const r of (pr2?.results || [])){
      if (!permMap[r.userId]) permMap[r.userId] = {};
      permMap[r.userId][r.permKey] = Number(r.enabled||0) ? true : false;
    }
  }

  const users = (rows?.results || []).map(u=>({
    id: u.id,
    email: u.email,
    role: u.role,
    status: u.status,
    createdAt: Number(u.createdAt||0),
    approvedAt: Number(u.approvedAt||0),
    approvedBy: u.approvedBy || "",
    perms: permMap[u.id] || {}
  }));

  return corsJson({ ok:true, users, build: BUILD_ID }, 200);
}

// ---- AUTH: admin users update (Bearer) ----
// POST /api/auth/admin/users/update {userId, role?, status?, perms?:{[permKey]:boolean}}
if (request.method === "POST" && url.pathname === "/api/auth/admin/users/update") {
  const auth = await authFromRequest(request, env);
  if (!auth) return corsJson({ ok:false, error:"forbidden", message:"login_required", build: BUILD_ID }, 403);

  const role = String(auth.user?.role || "");
  const perms = auth.perms || {};
  const allowed = (role === "admin" || role === "superadmin" || role === "super_admin" || perms["admin.users.manage"]);
  if (!allowed) return corsJson({ ok:false, error:"forbidden", message:"no_permission", build: BUILD_ID }, 403);

  const body = await request.json().catch(()=> ({}));
  const userId = String(body.userId || "").trim();
  if (!userId) return corsJson({ ok:false, error:"bad_request", message:"userId fehlt", build: BUILD_ID }, 400);

  const u = await env.DB.prepare(`SELECT id,email,role,status FROM auth_users WHERE id=? LIMIT 1`).bind(userId).first();
  if (!u) return corsJson({ ok:false, error:"not_found", build: BUILD_ID }, 404);

  const newRole = (typeof body.role === "string") ? String(body.role) : null;
  const newStatus = (typeof body.status === "string") ? String(body.status) : null;

  const now = Date.now();
  if (newRole || newStatus){
    const set = [];
    const bind = [];
    if (newRole){ set.push("role=?"); bind.push(newRole); }
    if (newStatus){ set.push("status=?"); bind.push(newStatus); }
    if (newStatus === "active"){ set.push("approvedAt=?"); bind.push(now); set.push("approvedBy=?"); bind.push(auth.user?.email || "admin"); }
    bind.push(userId);
    await env.DB.prepare(`UPDATE auth_users SET ${set.join(",")} WHERE id=?`).bind(...bind).run();
  }

  const p = body.perms && typeof body.perms === "object" ? body.perms : null;
  if (p){
    const entries = Object.entries(p);
    for (const [k,v] of entries){
      const enabled = v ? 1 : 0;
      await env.DB.prepare(`
        INSERT INTO auth_user_perms(userId, permKey, enabled)
        VALUES(?,?,?)
        ON CONFLICT(userId, permKey) DO UPDATE SET enabled=excluded.enabled
      `).bind(userId, String(k), enabled).run();
    }
  }

  return corsJson({ ok:true, build: BUILD_ID }, 200);
}
;

  await env.DB.prepare(`INSERT INTO config (k,v) VALUES ('config', ?)
                        ON CONFLICT(k) DO UPDATE SET v=excluded.v`)
    .bind(JSON.stringify(next))
    .run();

  await logEvent(env, "auth", "auth_config_set", au.user?.email || "auth", { changed: Object.keys(body || {}) });

  return corsJson({ ok:true, config: next, build: BUILD_ID }, 200);
}

// POST /api/admin/config/get {adminPassword}
      if (request.method === "POST" && url.pathname === "/api/admin/config/get") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);

        const cfg = await getConfig(env);

        // news seen count (current version)
        let seenCount = 0;
        if (cfg.newsEnabled && cfg.newsVersion > 0) {
          const row = await env.DB.prepare(`SELECT COUNT(*) AS c FROM news_seen WHERE newsVersion=?`).bind(cfg.newsVersion).first();
          seenCount = Number(row?.c || 0);
        }

        return corsJson({ ok: true, config: cfg, newsSeenCount: seenCount, build: BUILD_ID }, 200);
      }

      // POST /api/admin/config/set {adminPassword, ...}
      if (request.method === "POST" && url.pathname === "/api/admin/config/set") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);

        const cfg = await getConfig(env);

        // days window
        const daysPast = clampInt(body.daysPast, 0, 30, cfg.daysPast);
        const daysFuture = clampInt(body.daysFuture, 0, 30, cfg.daysFuture);

        // washer hours checkbox list 0..23
        const washerHours = Array.isArray(body.washerHours) ? body.washerHours.map(Number).filter(n => Number.isFinite(n) && n >= 0 && n <= 23) : cfg.washerHours;
        washerHours.sort((a,b)=>a-b);

        // dryer duration minutes 60/90/120
        const dryerMinutes = [60, 90, 120].includes(Number(body.dryerMinutes)) ? Number(body.dryerMinutes) : cfg.dryerMinutes;

        // defect toggles
        const userDefectEnabled = typeof body.userDefectEnabled === "boolean" ? body.userDefectEnabled : cfg.userDefectEnabled;
        const userDefectAllowed = typeof body.userDefectAllowed === "object" && body.userDefectAllowed ? body.userDefectAllowed : cfg.userDefectAllowed;

        // news
        const newsEnabled = typeof body.newsEnabled === "boolean" ? body.newsEnabled : cfg.newsEnabled;
        const newsText = typeof body.newsText === "string" ? body.newsText : cfg.newsText;
        let newsVersion = cfg.newsVersion;
        if (body.bumpNewsVersion) newsVersion = Number(cfg.newsVersion || 0) + 1;

        const next = {
          ...cfg,
          daysPast,
          daysFuture,
          washerHours,
          dryerMinutes,
          userDefectEnabled,
          userDefectAllowed,
          newsEnabled,
          newsText,
          newsVersion,
        };

        await kvSet(env, "config", JSON.stringify(next));
        await logEvent(env, "admin", "config_set", "admin", { changed: Object.keys(body || {}) });

        return corsJson({ ok: true, config: next, build: BUILD_ID }, 200);
      }

      // POST /api/admin/machines/set {adminPassword, updates:[{type,machine,enabled,defect}]}
      if (request.method === "POST" && url.pathname === "/api/admin/machines/set") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);

        const updates = Array.isArray(body.updates) ? body.updates : [];
        for (const u of updates) {
          const type = normType(u.type);
          const machine = normMachine(u.machine, 4);
          if (!type || !machine) continue;

          if (typeof u.enabled === "number") {
            await env.DB.prepare(`UPDATE machines SET enabled=? WHERE type=? AND machine=?`).bind(u.enabled ? 1 : 0, type, machine).run();
          }
          if (typeof u.defect === "number") {
            if (u.defect) {
              await setDefect(env, type, machine, 1, "admin", Date.now());
            } else {
              await setDefect(env, type, machine, 0, "", 0);
            }
          }
        }

        await logEvent(env, "admin", "machines_set", "admin", { count: updates.length });
        return corsJson({ ok: true, build: BUILD_ID }, 200);
      }

      // -----------------------------
// AUTH: Feedback (Bearer)  ‚Äî for PS/VS/Admin via perms
// -----------------------------
// POST /api/auth/feedback/threads {limit?}
if (request.method === "POST" && url.pathname === "/api/auth/feedback/threads") {
  const au = await authFromRequest(request, env);
  if (!au) return corsJson({ ok:false, error:"forbidden", message:"login_required", build: BUILD_ID }, 403);

  const role = String(au.user?.role || au.role || "");
  const perms = au.perms || {};
  const allowed = (role === "admin" || role === "superadmin" || role === "super_admin" || perms["admin.feedback.view"]);
  if (!allowed) return corsJson({ ok:false, error:"forbidden", message:"no_permission", build: BUILD_ID }, 403);

  const body = await request.json().catch(()=> ({}));
  const limit = clampInt(body.limit, 1, 500, 200);

  const rows = await env.DB.prepare(
    `SELECT id,room,subject,createdAt,updatedAt,allowUserView,userUnread,adminUnread,lastUserAt,lastAdminAt
     FROM feedback_threads
     ORDER BY updatedAt DESC
     LIMIT ?`
  ).bind(limit).all();

  return corsJson({ ok:true, threads: rows.results || [], build: BUILD_ID }, 200);
}

// compat: some older UIs used /api/auth/feedback/list
if (request.method === "POST" && url.pathname === "/api/auth/feedback/list") {
  const au = await authFromRequest(request, env);
  if (!au) return corsJson({ ok:false, error:"forbidden", message:"login_required", build: BUILD_ID }, 403);

  const role = String(au.user?.role || au.role || "");
  const perms = au.perms || {};
  const allowed = (role === "admin" || role === "superadmin" || role === "super_admin" || perms["admin.feedback.view"]);
  if (!allowed) return corsJson({ ok:false, error:"forbidden", message:"no_permission", build: BUILD_ID }, 403);

  const body = await request.json().catch(()=> ({}));
  const limit = clampInt(body.limit, 1, 500, 200);

  const rows = await env.DB.prepare(
    `SELECT id,room,subject,createdAt,updatedAt,allowUserView,userUnread,adminUnread,lastUserAt,lastAdminAt
     FROM feedback_threads
     ORDER BY updatedAt DESC
     LIMIT ?`
  ).bind(limit).all();

  return corsJson({ ok:true, threads: rows.results || [], build: BUILD_ID }, 200);
}

// POST /api/auth/feedback/thread {threadId}
if (request.method === "POST" && url.pathname === "/api/auth/feedback/thread") {
  const au = await authFromRequest(request, env);
  if (!au) return corsJson({ ok:false, error:"forbidden", message:"login_required", build: BUILD_ID }, 403);

  const role = String(au.user?.role || au.role || "");
  const perms = au.perms || {};
  const allowed = (role === "admin" || role === "superadmin" || role === "super_admin" || perms["admin.feedback.view"]);
  if (!allowed) return corsJson({ ok:false, error:"forbidden", message:"no_permission", build: BUILD_ID }, 403);

  const body = await request.json().catch(()=> ({}));
  const threadId = String(body.threadId || "").trim();
  if (!threadId) return corsJson({ ok:false, error:"bad_request", message:"threadId fehlt", build: BUILD_ID }, 400);

  const thread = await env.DB.prepare(
    `SELECT id,room,subject,createdAt,updatedAt,adminUnread,allowUserView
     FROM feedback_threads WHERE id=? LIMIT 1`
  ).bind(threadId).first();
  if (!thread) return corsJson({ ok:false, error:"not_found", build: BUILD_ID }, 404);

  const msgs = await env.DB.prepare(
    `SELECT id,threadId,sender,message,ts,visibleToUser,readByUser,readByAdmin
     FROM feedback_msgs WHERE threadId=? ORDER BY ts ASC`
  ).bind(threadId).all();

  await env.DB.prepare(`UPDATE feedback_msgs SET readByAdmin=1 WHERE threadId=?`).bind(threadId).run();
  await env.DB.prepare(`UPDATE feedback_threads SET adminUnread=0 WHERE id=?`).bind(threadId).run();

  return corsJson({ ok:true, thread, messages: msgs.results || [], build: BUILD_ID }, 200);
}

// POST /api/auth/feedback/send {threadId,message,visibleToUser:boolean,allowUserView?:boolean}
if (request.method === "POST" && url.pathname === "/api/auth/feedback/send") {
  const au = await authFromRequest(request, env);
  if (!au) return corsJson({ ok:false, error:"forbidden", message:"login_required", build: BUILD_ID }, 403);

  const role = String(au.user?.role || au.role || "");
  const perms = au.perms || {};
  const allowed = (role === "admin" || role === "superadmin" || role === "super_admin" || perms["admin.feedback.reply"] || perms["admin.feedback.view"]);
  if (!allowed) return corsJson({ ok:false, error:"forbidden", message:"no_permission", build: BUILD_ID }, 403);

  const body = await request.json().catch(()=> ({}));
  const threadId = String(body.threadId || "").trim();
  const message = String(body.message || "").trim();
  const visibleToUser = body.visibleToUser === false ? 0 : 1;
  const allowUserView = (typeof body.allowUserView === "boolean") ? (body.allowUserView ? 1 : 0) : null;
  if (!threadId || !message) return corsJson({ ok:false, error:"bad_request", build: BUILD_ID }, 400);

  const now = Date.now();
  if (allowUserView !== null) {
    await env.DB.prepare(
      `UPDATE feedback_threads SET allowUserView=?, updatedAt=?, lastAdminAt=?, userUnread=1 WHERE id=?`
    ).bind(allowUserView, now, now, threadId).run();
  } else {
    await env.DB.prepare(
      `UPDATE feedback_threads SET updatedAt=?, lastAdminAt=?, userUnread=1 WHERE id=?`
    ).bind(now, now, threadId).run();
  }

  const msgId = crypto.randomUUID();
  await env.DB.prepare(
    `INSERT INTO feedback_msgs(id,threadId,sender,message,ts,visibleToUser,readByUser,readByAdmin)
     VALUES(?,?,?,?,?,?,?,?)`
  ).bind(msgId, threadId, "admin", message, now, visibleToUser, 0, 1).run();

  await logEvent(env, "auth", "feedback_reply", au.user?.email || "auth", { threadId, msgId, visibleToUser });

  return corsJson({ ok:true, msgId, build: BUILD_ID }, 200);
}

// POST /api/admin/feedback/list {adminPassword}
      if (request.method === "POST" && url.pathname === "/api/admin/feedback/list") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);

        const rows = await env.DB.prepare(
          `SELECT id,room,createdAt,updatedAt,allowUserView,userUnread,adminUnread,lastUserAt,lastAdminAt
           FROM feedback_threads
           ORDER BY updatedAt DESC
           LIMIT 200`
        ).all();

        return corsJson({ ok: true, threads: rows.results || [], build: BUILD_ID }, 200);
      }

      // POST /api/admin/feedback/thread {adminPassword,threadId}
      if (request.method === "POST" && url.pathname === "/api/admin/feedback/thread") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const threadId = String(body.threadId || "");
        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
        if (!threadId) return corsJson({ ok: false, error: "bad_request", build: BUILD_ID }, 400);

        const thread = await env.DB.prepare(
          `SELECT id,room,allowUserView,userUnread,adminUnread,createdAt,updatedAt FROM feedback_threads WHERE id=? LIMIT 1`
        ).bind(threadId).first();
        if (!thread) return corsJson({ ok: false, error: "not_found", build: BUILD_ID }, 404);

        const msgs = await env.DB.prepare(
          `SELECT id,threadId,sender,message,ts,visibleToUser,readByUser,readByAdmin
           FROM feedback_msgs WHERE threadId=? ORDER BY ts ASC`
        ).bind(threadId).all();

        // mark read by admin
        await env.DB.prepare(`UPDATE feedback_msgs SET readByAdmin=1 WHERE threadId=?`).bind(threadId).run();
        await env.DB.prepare(`UPDATE feedback_threads SET adminUnread=0 WHERE id=?`).bind(threadId).run();

        return corsJson({ ok: true, thread, messages: msgs.results || [], build: BUILD_ID }, 200);
      }

      // POST /api/admin/feedback/send {adminPassword,threadId,message,visibleToUser:boolean,allowUserView?:boolean}
      if (request.method === "POST" && url.pathname === "/api/admin/feedback/send") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const threadId = String(body.threadId || "");
        const message = String(body.message || "").trim();
        const visibleToUser = body.visibleToUser === false ? 0 : 1;
        const allowUserView = typeof body.allowUserView === "boolean" ? (body.allowUserView ? 1 : 0) : null;

        if (!(await checkAdminPassword(env, pw))) return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
        if (!threadId || !message) return corsJson({ ok: false, error: "bad_request", build: BUILD_ID }, 400);

        const now = Date.now();

if (allowUserView !== null) {
  await env.DB.prepare(`UPDATE feedback_threads SET allowUserView=?, updatedAt=?, lastAdminAt=?, userUnread=1 WHERE id=?`)
    .bind(allowUserView, now, now, threadId).run();
} else {
  await env.DB.prepare(`UPDATE feedback_threads SET updatedAt=?, lastAdminAt=?, userUnread=1 WHERE id=?`)
    .bind(now, now, threadId).run();
}

        const msgId = crypto.randomUUID();
        await env.DB.prepare(
          `INSERT INTO feedback_msgs(id,threadId,sender,message,ts,visibleToUser,readByUser,readByAdmin)
           VALUES(?,?,?,?,?,?,?,?)`
        ).bind(msgId, threadId, "admin", message, now, visibleToUser, 0, 1).run();

        await logEvent(env, "admin", "feedback_reply", "admin", { threadId, msgId, visibleToUser });

        return corsJson({ ok: true, msgId, build: BUILD_ID }, 200);
      }

      
      // ---- AUTH: logs (Bearer) ----
      // POST /api/auth/logs {limit}
      if (request.method === "POST" && url.pathname === "/api/auth/logs") {
        const auth = await authFromRequest(request, env);
        if (!auth) return corsJson({ ok: false, error: "forbidden", message: "login_required", build: BUILD_ID }, 403);
        if (!auth.perms["admin.logs.view"]) return corsJson({ ok: false, error: "forbidden", message: "no_permission", build: BUILD_ID }, 403);

        const body = await request.json().catch(() => ({}));
        const limit = clampInt(body.limit, 1, 2000, 500);

        const cfg = await getConfig(env);
        const role = String(auth.user?.role || "");
        // Admins sehen immer alles; PS/VS optional √ºber cfg.roleWindows begrenzen
        const defaultDays = (role === "admin" || role === "superadmin" || role === "super_admin") ? 0 : getRoleWindowDays(cfg, role, "logsDays", 30);
        const reqDays = Number(body.rangeDays);
        const days = Number.isFinite(reqDays) ? clampInt(reqDays, 0, 3650, defaultDays) : defaultDays;
        const since = computeSinceFromDays(days);

        const rows = since
          ? await env.DB.prepare(
              `SELECT id,ts,actor,action,room,meta, NULL AS type, NULL AS machine
               FROM logs
               WHERE ts >= ?
               ORDER BY ts DESC
               LIMIT ?`
            ).bind(since, limit).all()
          : await env.DB.prepare(
              `SELECT id,ts,actor,action,room,meta, NULL AS type, NULL AS machine
               FROM logs
               ORDER BY ts DESC
               LIMIT ?`
            ).bind(limit).all();


        return corsJson({ ok: true, logs: rows.results || [], build: BUILD_ID }, 200);
      }

      // ---- AUTH: bookings list (Bearer) ----
      // POST /api/auth/bookings/list {limit}
      if (request.method === "POST" && url.pathname === "/api/auth/bookings/list") {
        const auth = await authFromRequest(request, env);
        if (!auth) return corsJson({ ok: false, error: "forbidden", message: "login_required", build: BUILD_ID }, 403);
        if (!auth.perms["admin.bookings.view"]) return corsJson({ ok: false, error: "forbidden", message: "no_permission", build: BUILD_ID }, 403);

        const body = await request.json().catch(() => ({}));
        const limit = clampInt(body.limit, 1, 2000, 800);

        const cfg = await getConfig(env);
        const role = String(auth.user?.role || "");
        const defaultDays = (role === "admin" || role === "superadmin" || role === "super_admin") ? 0 : getRoleWindowDays(cfg, role, "bookingsDays", 30);
        const reqDays = Number(body.rangeDays);
        const days = Number.isFinite(reqDays) ? clampInt(reqDays, 0, 3650, defaultDays) : defaultDays;
        const since = computeSinceFromDays(days);

        const rows = since
          ? await env.DB.prepare(
              `SELECT id,type,machine,start,end,room,status,createdAt,cancelledAt,releasedAt
               FROM bookings
               WHERE start >= ?
               ORDER BY start DESC
               LIMIT ?`
            ).bind(since, limit).all()
          : await env.DB.prepare(
              `SELECT id,type,machine,start,end,room,status,createdAt,cancelledAt,releasedAt
               FROM bookings
               ORDER BY start DESC
               LIMIT ?`
            ).bind(limit).all();


        return corsJson({ ok: true, bookings: rows.results || [], build: BUILD_ID }, 200);
      }

      // compat: old path
      if (request.method === "POST" && url.pathname === "/api/auth/bookings") {
              const auth = await authFromRequest(request, env);
              if (!auth) return corsJson({ ok: false, error: "forbidden", message: "login_required", build: BUILD_ID }, 403);
              if (!auth.perms["admin.bookings.view"]) return corsJson({ ok: false, error: "forbidden", message: "no_permission", build: BUILD_ID }, 403);
      
              const body = await request.json().catch(() => ({}));
              const limit = clampInt(body.limit, 1, 2000, 500);
              const rows = await env.DB.prepare(
                `SELECT id,type,machine,start,end,room,status,createdAt,cancelledAt,releasedAt FROM bookings ORDER BY start DESC LIMIT ?`
              ).bind(limit).all();
      
              return corsJson({ ok: true, bookings: rows.results || [], build: BUILD_ID }, 200);
            }

      // ---- AUTH: cancel booking (ps/ps_deputy/admin) ----
// POST /api/auth/bookings/cancel {id}
if (request.method === "POST" && url.pathname === "/api/auth/bookings/cancel") {
  const auth = await authFromRequest(request, env);
  if (!auth) return corsJson({ ok: false, error: "forbidden", message:"login_required", build: BUILD_ID }, 403);

  // aktuell: PS/VS/Admin d√ºrfen stornieren. Optional: zus√§tzlich per Permission.
  if (!(["ps","ps_deputy","admin","superadmin","super_admin"].includes(String(auth.user?.role||"")) || auth.perms?.["admin.bookings.cancel"])) {
    return corsJson({ ok:false, error:"forbidden", message:"no_permission", build: BUILD_ID }, 403);
  }

  try{
    const body = await request.json().catch(() => ({}));
    const id = String(body.id || "").trim();
    if (!id) return corsJson({ ok:false, error:"bad_request", message:"id fehlt", build: BUILD_ID }, 400);

    const b = await env.DB.prepare(
      `SELECT id,room,type,machine,status,start,end FROM bookings WHERE id=?`
    ).bind(id).first();
    if (!b) return corsJson({ ok:false, error:"not_found", build: BUILD_ID }, 404);

    const res = await env.DB.prepare(
      `UPDATE bookings SET status='admin_cancelled', cancelledAt=? WHERE id=? AND status='booked'`
    ).bind(Date.now(), id).run();

    const changes = Number(res?.meta?.changes ?? res?.changes ?? 0);
    if (changes === 0) {
      return corsJson({ ok:false, error:"conflict", message:"Buchung ist nicht mehr aktiv·Éê·ÉÆ·Éö·Éù·Éî·Éë·Éò·Éó (Status != booked)", build: BUILD_ID }, 409);
    }

    try{
      await logEvent(env, "auth", "auth_booking_cancel", String(b.room||""), {
        bookingId: id,
        type: b.type,
        machine: b.machine,
        start: b.start,
        end: b.end,
        byUserId: auth.user?.id,
        byRole: auth.user?.role,
        byEmail: auth.user?.email
      });
    }catch(_e){}

    return corsJson({ ok:true, build: BUILD_ID }, 200);
  }catch(e){
    return corsJson({ ok:false, error:"internal_error", message:String(e?.message||e), build: BUILD_ID }, 500);
  }
}



      // ---- AUTH: room control (Bearer) ----
      // POST /api/auth/room/control {room?, allRooms?:boolean, blocked?:boolean, message?:string}
      if (request.method === "POST" && url.pathname === "/api/auth/room/control") {
        const auth = await authFromRequest(request, env);
        if (!auth) return corsJson({ ok: false, error: "forbidden", message: "login_required", build: BUILD_ID }, 403);
        if (!(
          ["ps","ps_deputy","admin","superadmin"].includes(String(auth.user?.role||"")) ||
          auth.perms["ps.rooms.manage"] ||
          auth.perms["admin.users.manage"]
        )) return corsJson({ ok: false, error: "forbidden", message: "no_permission", build: BUILD_ID }, 403);

        const body = await request.json().catch(() => ({}));
        const allRooms = !!body.allRooms;
        const room = normRoom(body.room);

        const setBlocked = (typeof body.blocked === "boolean") ? (body.blocked ? 1 : 0) : null;
        const setMessage = (typeof body.message === "string") ? String(body.message).slice(0, 2000) : null;

        if (!allRooms && !room) return corsJson({ ok: false, error: "bad_request", message: "room fehlt", build: BUILD_ID }, 400);
        if (setBlocked === null && setMessage === null) return corsJson({ ok: false, error: "bad_request", message: "nichts zu setzen", build: BUILD_ID }, 400);

        const now = Date.now();
        const byRole = auth.user.role;
        const byEmail = auth.user.email || "";

        let rooms = [];
        if (allRooms) {
          const r = await env.DB.prepare(`SELECT room FROM room_pins`).all();
          rooms = (r.results || []).map(x => String(x.room)).filter(Boolean);
        } else {
          rooms = [room];
        }

        let count = 0;
        for (const rr of rooms) {
          const cur = await env.DB.prepare(`SELECT room FROM room_controls WHERE room=? LIMIT 1`).bind(rr).first();
          if (cur) {
            const parts = [];
            if (setBlocked !== null) parts.push("blocked=?");
            if (setMessage !== null) parts.push("message=?");
            const sql = `UPDATE room_controls SET ${parts.join(",")}, updatedAt=?, updatedByRole=?, updatedByEmail=? WHERE room=?`;
            const bind = [];
            if (setBlocked !== null) bind.push(setBlocked);
            if (setMessage !== null) bind.push(setMessage);
            bind.push(now, byRole, byEmail, rr);
            await env.DB.prepare(sql).bind(...bind).run();
          } else {
            await env.DB.prepare(
              `INSERT INTO room_controls(room,blocked,message,updatedAt,updatedByRole,updatedByEmail) VALUES(?,?,?,?,?,?)`
            ).bind(rr, setBlocked !== null ? setBlocked : 0, setMessage !== null ? setMessage : "", now, byRole, byEmail).run();
          }
          count++;
        }

        if (allRooms) return corsJson({ ok: true, count, build: BUILD_ID }, 200);

        const out = await env.DB.prepare(`SELECT blocked,message,updatedAt,updatedByRole,updatedByEmail FROM room_controls WHERE room=?`).bind(room).first();
        return corsJson({ ok: true, roomControl: { blocked: !!out?.blocked, message: out?.message || "" }, build: BUILD_ID }, 200);
      }

// POST /api/admin/logs {adminPassword, limit}

      // ---- ADMIN: Patientensprecher/Deputy/Admin list ----
      // POST /api/admin/ps/list {adminPassword}
      if (request.method === "POST" && url.pathname === "/api/admin/ps/list") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        if (!(await checkAdminPassword(env, pw))) {
        return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
        }

        const rows = await env.DB.prepare(`
          SELECT id,role,role2,firstName,lastName,email,status,createdAt,approvedAt,approvedBy,deleteMarkedAt,deleteAfter
          FROM auth_users
          WHERE role IN ('ps','ps_deputy','admin')
          ORDER BY createdAt DESC
          LIMIT 500
        `).all();

        return corsJson({ ok: true, users: rows.results || [], build: BUILD_ID }, 200);
      }

      // ---- ADMIN: approve user (auto-revoke previous ps/ps_deputy) ----
      // POST /api/admin/ps/approve {adminPassword,userId}
if (request.method === "POST" && url.pathname === "/api/admin/ps/approve") {
  const body = await request.json().catch(() => ({}));
  const pw = String(body.adminPassword || "").trim();
  const userId = String(body.userId || "").trim();

  if (!(await checkAdminPassword(env, pw))) {
        return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
  }
  if (!userId) {
        return corsJson({ ok: false, error: "bad_request", message: "userId fehlt", build: BUILD_ID }, 400);
  }

  const u = await env.DB.prepare(`
    SELECT id, role, status
    FROM auth_users
    WHERE id=?
    LIMIT 1
  `).bind(userId).first();

  if (!u) return corsJson({ ok: false, error: "not_found", build: BUILD_ID }, 404);

  const now = Date.now();

  // Wenn PS oder Stellvertreter: alten aktiven derselben Rolle deaktivieren
  if (u.role === "ps" || u.role === "ps_deputy") {
    const old = await env.DB.prepare(`
      SELECT id
      FROM auth_users
      WHERE role=? AND status='active' AND id<>?
      ORDER BY approvedAt DESC, createdAt DESC
      LIMIT 1
    `).bind(u.role, u.id).first();

    if (old?.id) {
      await env.DB.prepare(`
        UPDATE auth_users SET status='disabled', privacyVisibleUntil=0
        WHERE id=?
      `).bind(old.id).run();

      // Sessions / Codes / Rechte weg
      await env.DB.prepare(`DELETE FROM auth_sessions WHERE userId=?`).bind(old.id).run();
      await env.DB.prepare(`DELETE FROM auth_login_codes WHERE userId=?`).bind(old.id).run();
      await env.DB.prepare(`DELETE FROM auth_user_perms WHERE userId=?`).bind(old.id).run();

      await logEvent(env, "admin", "auth_prev_revoked", "admin", { oldUserId: old.id, role: u.role });
    }
  }

  // neuen freischalten
  await env.DB.prepare(`
    UPDATE auth_users
    SET status='active', approvedAt=?, approvedBy='superadmin', privacyVisibleUntil=0
    WHERE id=?
  `).bind(now, u.id).run();

  await logEvent(env, "admin", "auth_user_approved", "admin", { userId: u.id, role: u.role });

  return corsJson({ ok: true, build: BUILD_ID }, 200);
}

      if (request.method === "POST" && url.pathname === "/api/admin/ps/code") {
        const body = await request.json().catch(() => ({}));
        const pw = String(body.adminPassword || "").trim();
        const userId = String(body.userId || "").trim();

        if (!(await checkAdminPassword(env, pw))) {
        return corsJson({ ok: false, error: "forbidden", build: BUILD_ID }, 403);
        }
        if (!userId) {
        return corsJson({ ok: false, error: "bad_request", message: "userId fehlt", build: BUILD_ID }, 400);
        }

        const u = await env.DB.prepare(`
          SELECT id,email,role,status
          FROM auth_users
          WHERE id=? AND role IN ('ps','ps_deputy','admin')
          LIMIT 1
        `).bind(userId).first();

        if (!u) return corsJson({ ok: false, error: "not_found", build: BUILD_ID }, 404);
        if (u.status !== "active") {
        return corsJson({ ok: false, error: "not_active", message: "Bitte erst freischalten", build: BUILD_ID }, 409);
        }

        const code = gen6Code();
        const now = Date.now();
        const expiresAt = now + 30 * 60 * 1000;

        const codeHash = await sha256Hex(`${u.email}|${code}|${expiresAt}`);
        const id = crypto.randomUUID();

        await env.DB.prepare(`
          INSERT INTO auth_login_codes(id,userId,codeHash,expiresAt,createdAt,createdBy)
          VALUES(?,?,?,?,?,?)
        `).bind(id, u.id, codeHash, expiresAt, now, "superadmin").run();
        // ---- Mail: Login-Code senden (Resend) ----
try {
  await sendResendEmail(env, {
    to: u.email,
    subject: "Dein Washportal Login-Code",
    text:
`Hallo,

dein Login-Code: ${code}
G√ºltig bis: ${new Date(expiresAt).toLocaleString("de-DE")}

Viele Gr√º√üe
Washportal`
  });

  await logEvent(env, "admin", "auth_code_email_sent", "admin", { userId: u.id, role: u.role });
} catch (e) {
  // Mail ist optional: Code wird weiterhin im Admin angezeigt
  await logEvent(env, "admin", "auth_code_email_failed", "admin", {
    userId: u.id,
    role: u.role,
    err: String(e?.message || e)
  });
}


        await logEvent(env, "admin", "auth_code_created", "admin", { userId: u.id, role: u.role });

        return corsJson({ ok: true, code, expiresAt, role: u.role, build: BUILD_ID }, 200);
      }

      // -----------------------------
      // Fallback
      // -----------------------------
      return corsJson({
        ok: false,
        error: "not_found",
        build: BUILD_ID,
        debug: { method: request.method, pathname: url.pathname, fullUrl: url.toString() }
      }, 404);

    } catch (e) {
        return corsJson({
        ok: false,
        error: "internal_error",
        message: String(e?.message || e),
        stack: String(e?.stack || ""),
        build: BUILD_ID
      }, 500);
    }
  }
};


// =====================
// Helpers
// =====================
function corsHeaders(extra = {}) {
        return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
    ...extra,
  };
}
function corsJson(obj, status = 200) {
        return new Response(JSON.stringify(obj), {
    status,
    headers: corsHeaders({ "Content-Type": "application/json; charset=utf-8" }),
  });
}

function clampInt(v, min, max, fallback) {
  const n = Number(v);
  if (!Number.isFinite(n)) return fallback;
  return Math.min(max, Math.max(min, Math.trunc(n)));
}function getRoleWindowDays(cfg, role, kind, fallbackDays){
  try{
    if (!cfg || !cfg.roleWindows) return fallbackDays;
    const rw = cfg.roleWindows[role] || cfg.roleWindows[String(role||"")] || null;
    if (!rw) return fallbackDays;
    const v = Number(rw[kind]);
    if (!Number.isFinite(v)) return fallbackDays;
    return clampInt(v, 0, 3650, fallbackDays);
  }catch(_e){
    return fallbackDays;
  }
}

function computeSinceFromDays(days){
  const d = Number(days||0);
  if (!Number.isFinite(d) || d<=0) return 0;
  return Date.now() - d*24*60*60*1000;
}

function normRoom(v) {
  const s = String(v || "").trim();
  if (!/^\d{1,3}$/.test(s)) return "";
  const n = Number(s);
  if (!Number.isFinite(n) || n < 0 || n > 400) return "";
  return String(n);
}
function normPin(v) {
  const s = String(v || "").trim();
  if (!/^\d{4}$/.test(s)) return "";
  return s;
}
function normType(v) {
  const s = String(v || "").trim();
  if (s !== "washer" && s !== "dryer") return "";
  return s;
}
function normMachine(v, max) {
  const n = Number(v);
  if (!Number.isFinite(n) || n < 1 || n > max) return 0;
  return Math.trunc(n);
}

// =====================
// Password hashing (PBKDF2)
// Format: pbkdf2$iters$saltB64$hashB64
// =====================
async function hashPassword(pw, iterations = 50000) {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const key = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(pw),
    { name: "PBKDF2" },
    false,
    ["deriveBits"]
  );
  const bits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", hash: "SHA-256", salt, iterations },
    key,
    256
  );
  const hash = new Uint8Array(bits);
  return `pbkdf2$${iterations}$${b64(salt)}$${b64(hash)}`;
}

// ===== RESEND MAIL HELPER (NEU) =====
async function sendResendEmail(env, { to, subject, text }) {
  if (!env.RESEND_API_KEY) throw new Error("RESEND_API_KEY missing");

  const from = env.RESEND_FROM || "onboarding@resend.dev";

  const r = await fetch("https://api.resend.com/emails", {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + env.RESEND_API_KEY,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      from,
      to: Array.isArray(to) ? to : [to],
      subject,
      text,
    }),
  });

  const data = await r.json().catch(() => ({}));
  if (!r.ok) throw new Error(data?.message || `Resend error ${r.status}`);

  return data;
}

async function verifyPassword(pw, stored) {
  try {
    const parts = String(stored || "").split("$");
    if (parts.length !== 4) return false;

    const iters = Number(parts[1]);
    const salt = ub64(parts[2]);
    const hashB64 = parts[3];

    if (!Number.isFinite(iters) || iters < 1000) return false;

    const key = await crypto.subtle.importKey(
      "raw",
      new TextEncoder().encode(String(pw)),
      { name: "PBKDF2" },
      false,
      ["deriveBits"]
    );

    const bits = await crypto.subtle.deriveBits(
      { name: "PBKDF2", hash: "SHA-256", salt, iterations: iters },
      key,
      256
    );

    const gotB64 = b64(new Uint8Array(bits));
    return gotB64 === hashB64;
  } catch (e) {
    // wichtig: NIE crashen lassen, einfach false
    return false;
  }
}


function b64(u8) {
  let s = "";
  for (const c of u8) s += String.fromCharCode(c);
  return btoa(s);
}
function ub64(s) {
  const bin = atob(s);
  const u8 = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
  return u8;
}

// =====================
// Schema + KV
// =====================
async function ensureSchema(env) {
  // kv store
  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS kv_store(
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL
    )`
  ).run();

  // room pins
  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS room_pins(
      room TEXT PRIMARY KEY,
      pinHash TEXT NOT NULL,
      createdAt INTEGER NOT NULL,
      updatedAt INTEGER NOT NULL
    )`
  ).run()

  // room controls (message + blocked flag) - independent of PIN
  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS room_controls(
      room TEXT PRIMARY KEY,
      blocked INTEGER NOT NULL DEFAULT 0,
      message TEXT NOT NULL DEFAULT '',
      updatedAt INTEGER NOT NULL DEFAULT 0,
      updatedByRole TEXT NOT NULL DEFAULT '',
      updatedByEmail TEXT NOT NULL DEFAULT ''
    )`
  ).run();
;

  // machines
  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS machines(
      type TEXT NOT NULL,
      machine INTEGER NOT NULL,
      enabled INTEGER NOT NULL DEFAULT 1,
      defect INTEGER NOT NULL DEFAULT 0,
      defectBy TEXT NOT NULL DEFAULT '',
      defectAt INTEGER NOT NULL DEFAULT 0,
      lastRoom TEXT NOT NULL DEFAULT '',
      lastAt INTEGER NOT NULL DEFAULT 0,
      PRIMARY KEY(type,machine)
    )`
  ).run();

  // bookings
  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS bookings(
      id TEXT PRIMARY KEY,
      type TEXT NOT NULL,
      machine INTEGER NOT NULL,
      start INTEGER NOT NULL,
      end INTEGER NOT NULL,
      room TEXT NOT NULL,
      pinHash TEXT NOT NULL,
      status TEXT NOT NULL,
      createdAt INTEGER NOT NULL,
      cancelledAt INTEGER NOT NULL DEFAULT 0,
      releasedAt INTEGER NOT NULL DEFAULT 0
    )`
  ).run();

  await env.DB.prepare(
    `CREATE INDEX IF NOT EXISTS idx_bookings_type_machine_time
     ON bookings(type, machine, start, end, status)`
  ).run();

  // logs
  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS logs(
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      ts INTEGER NOT NULL,
      actor TEXT NOT NULL,
      action TEXT NOT NULL,
      room TEXT NOT NULL,
      meta TEXT NOT NULL
    )`
  ).run();

  // feedback threads/messages
  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS feedback_threads(
      id TEXT PRIMARY KEY,
      room TEXT NOT NULL,
      pinHash TEXT NOT NULL,
      createdAt INTEGER NOT NULL,
      updatedAt INTEGER NOT NULL,
      lastUserAt INTEGER NOT NULL DEFAULT 0,
      lastAdminAt INTEGER NOT NULL DEFAULT 0,
      userUnread INTEGER NOT NULL DEFAULT 0,
      adminUnread INTEGER NOT NULL DEFAULT 0,
      allowUserView INTEGER NOT NULL DEFAULT 1
    )`
  ).run();

  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS feedback_msgs(
      id TEXT PRIMARY KEY,
      threadId TEXT NOT NULL,
      sender TEXT NOT NULL,
      message TEXT NOT NULL,
      ts INTEGER NOT NULL,
      visibleToUser INTEGER NOT NULL DEFAULT 1,
      readByUser INTEGER NOT NULL DEFAULT 0,
      readByAdmin INTEGER NOT NULL DEFAULT 0
    )`
  ).run();

  await env.DB.prepare(
    `CREATE INDEX IF NOT EXISTS idx_feedback_thread_ts
     ON feedback_msgs(threadId, ts)`
  ).run();

  // news seen
  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS news_seen(
      room TEXT NOT NULL,
      pinHash TEXT NOT NULL,
      newsVersion INTEGER NOT NULL,
      ts INTEGER NOT NULL,
      PRIMARY KEY(room,pinHash,newsVersion)
    )`
  ).run();

  // auth users (admins + patient speakers)
  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS auth_users(
      id TEXT PRIMARY KEY,
      role TEXT NOT NULL, -- 'super_admin' | 'admin' | 'ps' | 'ps_deputy'
      firstName TEXT NOT NULL DEFAULT '',
      lastName TEXT NOT NULL DEFAULT '',
      email TEXT NOT NULL UNIQUE,
      passwordHash TEXT NOT NULL DEFAULT '',
      status TEXT NOT NULL DEFAULT 'pending', -- 'pending' | 'active' | 'disabled' | 'pending_delete'
      createdAt INTEGER NOT NULL,
      approvedAt INTEGER NOT NULL DEFAULT 0,
      approvedBy TEXT NOT NULL DEFAULT '',
      privacyVisibleUntil INTEGER NOT NULL DEFAULT 0
    )`
  ).run();

  
  // migrate auth_users: add optional columns if missing
  try { await env.DB.prepare(`ALTER TABLE auth_users ADD COLUMN role2 TEXT NOT NULL DEFAULT ''`).run(); } catch(e) {}
  try { await env.DB.prepare(`ALTER TABLE auth_users ADD COLUMN passwordHash TEXT NOT NULL DEFAULT ''`).run(); } catch(e) {}
  try { await env.DB.prepare(`ALTER TABLE auth_users ADD COLUMN pwUpdatedAt INTEGER NOT NULL DEFAULT 0`).run(); } catch(e) {}
  try { await env.DB.prepare(`ALTER TABLE auth_users ADD COLUMN deleteMarkedAt INTEGER NOT NULL DEFAULT 0`).run(); } catch(e) {}
  try { await env.DB.prepare(`ALTER TABLE auth_users ADD COLUMN deleteAfter INTEGER NOT NULL DEFAULT 0`).run(); } catch(e) {}

await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS auth_login_codes(
      id TEXT PRIMARY KEY,
      userId TEXT NOT NULL,
      codeHash TEXT NOT NULL,
      createdAt INTEGER NOT NULL,
      expiresAt INTEGER NOT NULL,
      usedAt INTEGER NOT NULL DEFAULT 0
    )`
  ).run();

  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS auth_sessions(
      tokenHash TEXT PRIMARY KEY,
      userId TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT '',
      createdAt INTEGER NOT NULL,
      expiresAt INTEGER NOT NULL
    )`
  ).run();

  // migrate auth_sessions: add role column if missing (older schema)
  try {
    const cols = await env.DB.prepare(`PRAGMA table_info(auth_sessions)`).all();
    const hasRole = (cols.results || []).some(r => r.name === "role");
    if (!hasRole) {
      await env.DB.prepare(`ALTER TABLE auth_sessions ADD COLUMN role TEXT NOT NULL DEFAULT ''`).run();
    }
  } catch (_) {}

  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS auth_perms(
      permKey TEXT PRIMARY KEY,
      label TEXT NOT NULL
    )`
  ).run();

  await env.DB.prepare(
    `CREATE TABLE IF NOT EXISTS auth_user_perms(
      userId TEXT NOT NULL,
      permKey TEXT NOT NULL,
      allowed INTEGER NOT NULL DEFAULT 1,
      PRIMARY KEY(userId, permKey)
    )`
  ).run();

  // seed known perms
  const permCountRow = await env.DB.prepare(`SELECT COUNT(*) AS c FROM auth_perms`).first();
  const permCount = Number(permCountRow?.c || 0);
  if (permCount === 0) {
    const perms = [
      ["admin.logs.view", "Logs ansehen"],
      ["admin.bookings.view", "Buchungen ansehen"],
      ["admin.bookings.cancel", "Buchungen stornieren"],
      ["admin.feedback.view", "Feedback ansehen"],
      ["admin.feedback.delete", "Feedback l√∂schen"],
      ["admin.news.edit", "News bearbeiten"],
      ["admin.users.manage", "Benutzerverwaltung"],
      ["ps.news.view", "PS-News sehen"],
      ["ps.feedback.view", "PS-Feedback sehen"],
      ["ps.rooms.manage", "Zimmer verwalten"]
    ];
    for (const [k,label] of perms) {
      await env.DB.prepare(`INSERT INTO auth_perms(permKey,label) VALUES(?,?)`).bind(k,label).run();
    }
  }

  // seed machines if missing
  const row = await env.DB.prepare(`SELECT COUNT(*) AS c FROM machines`).first();
  const c = Number(row?.c || 0);
  if (c === 0) {
    // 4 washers + 4 dryers
    for (let i = 1; i <= 4; i++) {
      await env.DB.prepare(`INSERT INTO machines(type,machine,enabled,defect) VALUES('washer',?,1,0)`).bind(i).run();
    }
    for (let i = 1; i <= 4; i++) {
      await env.DB.prepare(`INSERT INTO machines(type,machine,enabled,defect) VALUES('dryer',?,1,0)`).bind(i).run();
    }
  }
// seed config default if missing
  const cfg = await kvGet(env, "config");
  if (!cfg) {
    const def = {
      daysPast: 1,
      daysFuture: 6,
      // washerHours = checkbox selection (default: 6,8,...,22)
      washerHours: [6, 8, 10, 12, 14, 16, 18, 20, 22],
      dryerMinutes: 120, // 60/90/120 selectable in admin
      userDefectEnabled: true,
      userDefectAllowed: {
        washer: { "1": true, "2": true, "3": true, "4": true },
        dryer: { "1": true, "2": true, "3": true, "4": true },
      },
      newsEnabled: false,
      newsText: "",
      newsVersion: 0,
    };
    await kvSet(env, "config", JSON.stringify(def));
  }
}

async function kvGet(env, key) {
  const row = await env.DB.prepare(`SELECT value FROM kv_store WHERE key=? LIMIT 1`).bind(key).first();
  return row?.value || "";
}
async function kvSet(env, key, value) {
  await env.DB.prepare(`INSERT INTO kv_store(key,value) VALUES(?,?)
                        ON CONFLICT(key) DO UPDATE SET value=excluded.value`)
    .bind(key, String(value)).run();
}

// =====================
// Config
// =====================
async function getConfig(env) {
  const raw = await kvGet(env, "config");
  let cfg = {};
  try { cfg = JSON.parse(raw || "{}"); } catch { cfg = {}; }

  // ensure shape
  cfg.daysPast = clampInt(cfg.daysPast, 0, 30, 1);
  cfg.daysFuture = clampInt(cfg.daysFuture, 0, 30, 6);
  cfg.washerHours = Array.isArray(cfg.washerHours) ? cfg.washerHours.map(Number).filter(n => n>=0 && n<=23) : [6,8,10,12,14,16,18,20,22];
  cfg.washerHours.sort((a,b)=>a-b);
  cfg.dryerMinutes = [60,90,120].includes(Number(cfg.dryerMinutes)) ? Number(cfg.dryerMinutes) : 120;
  cfg.userDefectEnabled = !!cfg.userDefectEnabled;
  cfg.userDefectAllowed = cfg.userDefectAllowed || { washer:{}, dryer:{} };
  cfg.newsEnabled = !!cfg.newsEnabled;
  cfg.newsText = String(cfg.newsText || "");
  cfg.newsVersion = Number(cfg.newsVersion || 0);

  // expose: fixed washer slot duration 2h
  cfg.washerSlotMinutes = 120;

  // admin present?
  cfg.hasAdmin = !!(await kvGet(env, "adminPwHash"));

  return cfg;
}

// =====================
// Machines
// =====================
async function listMachines(env) {
  const rows = await env.DB.prepare(
    `SELECT type,machine,enabled,defect,defectBy,defectAt,lastRoom,lastAt
     FROM machines ORDER BY type ASC, machine ASC`
  ).all();
  return rows.results || [];
}
async function getMachine(env, type, machine) {
        return await env.DB.prepare(
    `SELECT type,machine,enabled,defect,defectBy,defectAt,lastRoom,lastAt
     FROM machines WHERE type=? AND machine=? LIMIT 1`
  ).bind(type, machine).first();
}
async function setLastRoom(env, type, machine, room) {
  const now = Date.now();
  await env.DB.prepare(`UPDATE machines SET lastRoom=?, lastAt=? WHERE type=? AND machine=?`)
    .bind(String(room), now, type, machine).run();
}
async function setDefect(env, type, machine, defect, defectBy, defectAt) {
  await env.DB.prepare(`UPDATE machines SET defect=?, defectBy=?, defectAt=? WHERE type=? AND machine=?`)
    .bind(defect ? 1 : 0, String(defectBy || ""), Number(defectAt || 0), type, machine).run();
}

// =====================
// Auth
// =====================
async function sha256Hex(s) {
  const enc = new TextEncoder().encode(String(s));
  const hash = await crypto.subtle.digest("SHA-256", enc);
  return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");
}

async function makeSessionToken() {
  // 32 bytes random -> base64url
  const a = new Uint8Array(32);
  crypto.getRandomValues(a);
  let b64 = btoa(String.fromCharCode(...a));
  // base64url
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function makeShortCode() {
  // 8 chars, easy to read
  const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  const a = new Uint8Array(8);
  crypto.getRandomValues(a);
  return [...a].map(x => alphabet[x % alphabet.length]).join("");
}

async function authFromRequest(request, env) {
  const h = request.headers.get("authorization") || request.headers.get("Authorization") || "";
  const m = /^Bearer\s+(.+)$/i.exec(h);
  if (!m) return null;
  const token = m[1].trim();
  if (!token) return null;

  const tokenHash = await sha256Hex(token);
  const now = Date.now();

  const sess = await env.DB.prepare(
    `SELECT userId,expiresAt FROM auth_sessions WHERE tokenHash=? LIMIT 1`
  ).bind(tokenHash).first();

  if (!sess) return null;
  if (now > Number(sess.expiresAt || 0)) return null;

  const user = await env.DB.prepare(
    `SELECT id,role,status,firstName,lastName,email FROM auth_users WHERE id=? LIMIT 1`
  ).bind(sess.userId).first();

  if (!user || user.status !== "active") return null;

  const perms = await env.DB.prepare(
    `SELECT permKey,allowed FROM auth_user_perms WHERE userId=?`
  ).bind(user.id).all();

  const permMap = {};
  for (const r of (perms.results || [])) permMap[r.permKey] = !!r.allowed;

  // default: if user has no explicit perms yet, allow everything for now (admins can uncheck later)
  if (Object.keys(permMap).length === 0 && (user.role === "admin" || user.role === "ps" || user.role === "ps_deputy")) {
    permMap["admin.logs.view"] = true;
    permMap["admin.bookings.view"] = true;
    permMap["admin.bookings.cancel"] = true;
    permMap["admin.feedback.view"] = true;
    permMap["admin.feedback.delete"] = true;
    permMap["admin.news.edit"] = true;
    permMap["admin.users.manage"] = true;
    permMap["ps.news.view"] = true;
    permMap["ps.feedback.view"] = true;
    permMap["ps.rooms.manage"] = true;
  }

  return { user, perms: permMap };
}

async function checkAdminPassword(env, pw) {
  // if no adminPwHash -> allow initial once and set
  const stored = await kvGet(env, "adminPwHash");
  if (!stored) {
    if (pw === "initial") {
      const h = await hashPassword("initial", 50000);
      await kvSet(env, "adminPwHash", h);
      return true;
    }
    return false;
  }
  return await verifyPassword(pw, stored);
}

async function checkStationPin(env, stationPin) {
  const stored = await kvGet(env, "stationPinHash");
  if (!stored) return false; // must be set by admin
  return await verifyPassword(stationPin, stored);
}

function maskEmail(email) {
  const e = String(email || "").trim();
  const parts = e.split("@");
  if (parts.length !== 2) return e;
  const [u, d] = parts;
  if (!u) return e;
  return `${u.slice(0, 1)}***@${d}`;
}

function gen6Code() {
        return String(Math.floor(100000 + Math.random() * 900000)); // 6-stellig
}

async function ensureRoomAuth(env, room, pin) {
  // Basic attempt limiter (3 per 10 minutes)
  const now = Date.now();
  const since = now - 10 * 60 * 1000;
  const attempts = await env.DB.prepare(
    `SELECT COUNT(*) AS c FROM logs
     WHERE action='pin_failed' AND room=? AND ts>=?`
  ).bind(room, since).first();
  if (Number(attempts?.c || 0) >= 3) return false;

  // In v2 kann ein Zimmer mehrere PINs haben.
  // Wir suchen: existiert irgendein Hash f√ºr dieses Zimmer, der zu pin passt?
  const rows = await env.DB.prepare(
    `SELECT pinHash FROM room_pins_v2 WHERE room=?`
  ).bind(room).all();

  const list = rows?.results || [];

  for (const r of list) {
    if (await verifyPassword(pin, r.pinHash)) {
      // Treffer: updatedAt pflegen
      await env.DB.prepare(
        `UPDATE room_pins_v2 SET updatedAt=? WHERE room=? AND pinHash=?`
      ).bind(now, room, r.pinHash).run();
      return true;
    }
  }

  // Kein Treffer -> neuer PIN f√ºr dieses Zimmer registrieren
  const h = await hashPassword(pin, 50000);
  await env.DB.prepare(
    `INSERT OR IGNORE INTO room_pins_v2(room,pinHash,createdAt,updatedAt) VALUES(?,?,?,?)`
  ).bind(room, h, now, now).run();

  return true;
}


async function getRoomPinHash(env, room, pin) {
  const rows = await env.DB.prepare(
    `SELECT pinHash FROM room_pins_v2 WHERE room=?`
  ).bind(room).all();

  for (const r of (rows?.results || [])) {
    if (await verifyPassword(pin, r.pinHash)) return r.pinHash;
  }
  return "";
}


// =====================
// Window (ms)
/// daysPast includes today-1 etc.
// =====================
function computeTimeWindow(nowMs, daysPast, daysFuture) {
  const dayMs = 24 * 60 * 60 * 1000;
  const from = nowMs - daysPast * dayMs;
  const to = nowMs + daysFuture * dayMs;
  return { from, to };
}

// =====================
// Logs
// =====================
async function logEvent(env, actor, action, room, meta) {
  const ts = Date.now();
  await env.DB.prepare(
    `INSERT INTO logs(ts,actor,action,room,meta) VALUES(?,?,?,?,?)`
  ).bind(ts, String(actor), String(action), String(room), JSON.stringify(meta || {})).run();
}
